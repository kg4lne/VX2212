
VX2212.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ca0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00800060  00000ca0  00000d34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000342  00800070  00800070  00000d44  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000199  00000000  00000000  00000d84  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000f4e  00000000  00000000  00000f1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000583  00000000  00000000  00001e6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000b05  00000000  00000000  000023ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001a0  00000000  00000000  00002ef4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002c7  00000000  00000000  00003094  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000a9d  00000000  00000000  0000335b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  00003df8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	29 c0       	rjmp	.+82     	; 0x54 <__ctors_end>
   2:	bd c0       	rjmp	.+378    	; 0x17e <__vector_1>
   4:	42 c0       	rjmp	.+132    	; 0x8a <__bad_interrupt>
   6:	41 c0       	rjmp	.+130    	; 0x8a <__bad_interrupt>
   8:	40 c0       	rjmp	.+128    	; 0x8a <__bad_interrupt>
   a:	3f c0       	rjmp	.+126    	; 0x8a <__bad_interrupt>
   c:	3e c0       	rjmp	.+124    	; 0x8a <__bad_interrupt>
   e:	3d c0       	rjmp	.+122    	; 0x8a <__bad_interrupt>
  10:	3c c0       	rjmp	.+120    	; 0x8a <__bad_interrupt>
  12:	cf c0       	rjmp	.+414    	; 0x1b2 <__vector_9>
  14:	3a c0       	rjmp	.+116    	; 0x8a <__bad_interrupt>
  16:	b2 c4       	rjmp	.+2404   	; 0x97c <__vector_11>
  18:	6f c4       	rjmp	.+2270   	; 0x8f8 <__vector_12>
  1a:	64 c4       	rjmp	.+2248   	; 0x8e4 <__vector_13>
  1c:	36 c0       	rjmp	.+108    	; 0x8a <__bad_interrupt>
  1e:	35 c0       	rjmp	.+106    	; 0x8a <__bad_interrupt>
  20:	34 c0       	rjmp	.+104    	; 0x8a <__bad_interrupt>
  22:	33 c0       	rjmp	.+102    	; 0x8a <__bad_interrupt>
  24:	32 c0       	rjmp	.+100    	; 0x8a <__bad_interrupt>

00000026 <copyright>:
  26:	56 58 32 32 31 32 20 76 31 2e 30 30 2c 20 43 6f     VX2212 v1.00, Co
  36:	70 79 72 69 67 68 74 20 28 43 29 20 32 30 30 37     pyright (C) 2007
  46:	2d 32 30 30 39 2c 20 4b 47 34 4c 4e 45 00           -2009, KG4LNE.

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 ea       	ldi	r30, 0xA0	; 160
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 37       	cpi	r26, 0x70	; 112
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	13 e0       	ldi	r17, 0x03	; 3
  78:	a0 e7       	ldi	r26, 0x70	; 112
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 3b       	cpi	r26, 0xB2	; 178
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	24 d3       	rcall	.+1608   	; 0x6d0 <main>
  88:	09 c6       	rjmp	.+3090   	; 0xc9c <_exit>

0000008a <__bad_interrupt>:
  8a:	ba cf       	rjmp	.-140    	; 0x0 <__vectors>

0000008c <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
  8c:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
  8e:	e1 99       	sbic	0x1c, 1	; 28
  90:	fe cf       	rjmp	.-4      	; 0x8e <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
  92:	3f bb       	out	0x1f, r19	; 31
  94:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
  96:	e0 9a       	sbi	0x1c, 0	; 28
  98:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
  9a:	08 95       	ret

0000009c <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
  9c:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
  9e:	e1 99       	sbic	0x1c, 1	; 28
  a0:	fe cf       	rjmp	.-4      	; 0x9e <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
  a2:	3f bb       	out	0x1f, r19	; 31
  a4:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
  a6:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
  a8:	0f b6       	in	r0, 0x3f	; 63
  aa:	f8 94       	cli
  ac:	e2 9a       	sbi	0x1c, 2	; 28
  ae:	e1 9a       	sbi	0x1c, 1	; 28
  b0:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
  b2:	08 95       	ret

000000b4 <reset_radio>:

/* Issue a reset pulse to the radio CPU */

void reset_radio(void)
{
    PORTB |= _BV(B_RRST);
  b4:	c2 9a       	sbi	0x18, 2	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  b6:	84 ef       	ldi	r24, 0xF4	; 244
  b8:	91 e0       	ldi	r25, 0x01	; 1
  ba:	01 97       	sbiw	r24, 0x01	; 1
  bc:	f1 f7       	brne	.-4      	; 0xba <reset_radio+0x6>
    /* ~100us */
    _delay_loop_2(5*100);
    PORTB &= ~(_BV(B_RRST));
  be:	c2 98       	cbi	0x18, 2	; 24
    /* ~100us */
    //_delay_loop_2(5*100);
}
  c0:	08 95       	ret

000000c2 <blink_led>:

/* Blink the LED for count and rate duration */

void blink_led(uint16_t count, uint16_t rate)
{
  c2:	40 e0       	ldi	r20, 0x00	; 0
  c4:	50 e0       	ldi	r21, 0x00	; 0
  c6:	a6 e6       	ldi	r26, 0x66	; 102
  c8:	be e0       	ldi	r27, 0x0E	; 14
  ca:	1a c0       	rjmp	.+52     	; 0x100 <blink_led+0x3e>
    uint16_t i;
    /* Blink the n times at ms delay rate */
    for (i=0; i < count; i++)
    {
        PORTB |= _BV(B_LED);
  cc:	c4 9a       	sbi	0x18, 4	; 24
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	05 c0       	rjmp	.+10     	; 0xde <blink_led+0x1c>
  d4:	fd 01       	movw	r30, r26
  d6:	31 97       	sbiw	r30, 0x01	; 1
  d8:	f1 f7       	brne	.-4      	; 0xd6 <blink_led+0x14>

void delay_ms(uint16_t ms)
{
    uint16_t d;

    for (d=0; d < ms; d++) {
  da:	2f 5f       	subi	r18, 0xFF	; 255
  dc:	3f 4f       	sbci	r19, 0xFF	; 255
  de:	26 17       	cp	r18, r22
  e0:	37 07       	cpc	r19, r23
  e2:	c0 f3       	brcs	.-16     	; 0xd4 <blink_led+0x12>
    /* Blink the n times at ms delay rate */
    for (i=0; i < count; i++)
    {
        PORTB |= _BV(B_LED);
        delay_ms(rate);
        PORTB &= ~(_BV(B_LED));
  e4:	c4 98       	cbi	0x18, 4	; 24
  e6:	20 e0       	ldi	r18, 0x00	; 0
  e8:	30 e0       	ldi	r19, 0x00	; 0
  ea:	05 c0       	rjmp	.+10     	; 0xf6 <blink_led+0x34>
  ec:	fd 01       	movw	r30, r26
  ee:	31 97       	sbiw	r30, 0x01	; 1
  f0:	f1 f7       	brne	.-4      	; 0xee <blink_led+0x2c>

void delay_ms(uint16_t ms)
{
    uint16_t d;

    for (d=0; d < ms; d++) {
  f2:	2f 5f       	subi	r18, 0xFF	; 255
  f4:	3f 4f       	sbci	r19, 0xFF	; 255
  f6:	26 17       	cp	r18, r22
  f8:	37 07       	cpc	r19, r23
  fa:	c0 f3       	brcs	.-16     	; 0xec <blink_led+0x2a>

void blink_led(uint16_t count, uint16_t rate)
{
    uint16_t i;
    /* Blink the n times at ms delay rate */
    for (i=0; i < count; i++)
  fc:	4f 5f       	subi	r20, 0xFF	; 255
  fe:	5f 4f       	sbci	r21, 0xFF	; 255
 100:	48 17       	cp	r20, r24
 102:	59 07       	cpc	r21, r25
 104:	18 f3       	brcs	.-58     	; 0xcc <blink_led+0xa>
        PORTB |= _BV(B_LED);
        delay_ms(rate);
        PORTB &= ~(_BV(B_LED));
        delay_ms(rate);
    }
}
 106:	08 95       	ret

00000108 <init_io>:
     * ADC6 = /WE       (in)
     * ADC7 = /STORE    (in)
     */

    /* all pins low */
    PORTC = 0x00;
 108:	15 ba       	out	0x15, r1	; 21
    /* all pins are input */
    DDRC  = 0x00;
 10a:	14 ba       	out	0x14, r1	; 20
     * PD6  = D2        (in/out)
     * PD7  = D1        (in/out)
     */

    /* all pins low */
    PORTD = 0x00;
 10c:	12 ba       	out	0x12, r1	; 18
    /* all pins are input for now */
    DDRD  = 0x00;
 10e:	11 ba       	out	0x11, r1	; 17
    /* PD1=output, PD4-PD7=output */
    DDRD  = _BV(PD1) | _BV(PD4) | _BV(PD5) | _BV(PD6) | _BV(PD7);
 110:	82 ef       	ldi	r24, 0xF2	; 242
 112:	81 bb       	out	0x11, r24	; 17
     * PB4  = LED       (out)
     * PB5  = MODE      (in)
     */

    /* all pins low */
    PORTB = 0x00;
 114:	18 ba       	out	0x18, r1	; 24
    /* all pins are input for now */
    DDRB  = 0x00;
 116:	17 ba       	out	0x17, r1	; 23
    /* PB2-PB4=output, PB0, PB1 & PB5 are input */
    DDRB  = _BV(PB2) | _BV(PB3) | _BV(PB4);
 118:	8c e1       	ldi	r24, 0x1C	; 28
 11a:	87 bb       	out	0x17, r24	; 23
}
 11c:	08 95       	ret

0000011e <start_ints>:

/* Here we startup any interrupts or devices needed */

void start_ints(void)
{
    cli();
 11e:	f8 94       	cli
    /* enable the timer/counter1 overflow interrupt in the T/C int mask register */
    timer_enable_int(_BV(TOIE1));
#endif

	// Enable the external interrupt for INT0/PD2
    MCUCR   = (1<<ISC00);       // Set interrupt on fall and on rise
 120:	81 e0       	ldi	r24, 0x01	; 1
 122:	85 bf       	out	0x35, r24	; 53
    GICR	= (1<<INT0);		// Enable interrupt for interrupt0
 124:	80 e4       	ldi	r24, 0x40	; 64
 126:	8b bf       	out	0x3b, r24	; 59

    sei();
 128:	78 94       	sei
}
 12a:	08 95       	ret

0000012c <delay_ms>:
/****************************************************************************
 * General Purpose Functions
 ***************************************************************************/

void delay_ms(uint16_t ms)
{
 12c:	20 e0       	ldi	r18, 0x00	; 0
 12e:	30 e0       	ldi	r19, 0x00	; 0
 130:	46 e6       	ldi	r20, 0x66	; 102
 132:	5e e0       	ldi	r21, 0x0E	; 14
 134:	05 c0       	rjmp	.+10     	; 0x140 <delay_ms+0x14>
 136:	fa 01       	movw	r30, r20
 138:	31 97       	sbiw	r30, 0x01	; 1
 13a:	f1 f7       	brne	.-4      	; 0x138 <delay_ms+0xc>
    uint16_t d;

    for (d=0; d < ms; d++) {
 13c:	2f 5f       	subi	r18, 0xFF	; 255
 13e:	3f 4f       	sbci	r19, 0xFF	; 255
 140:	28 17       	cp	r18, r24
 142:	39 07       	cpc	r19, r25
 144:	c0 f3       	brcs	.-16     	; 0x136 <delay_ms+0xa>
        /* 16-bit count - 4 cycles/loop */
        _delay_loop_2((uint16_t)(F_CPU / 4000UL));
    }
}
 146:	08 95       	ret

00000148 <delay_us>:
 148:	03 96       	adiw	r24, 0x03	; 3
 14a:	63 e0       	ldi	r22, 0x03	; 3
 14c:	70 e0       	ldi	r23, 0x00	; 0
 14e:	5b d5       	rcall	.+2742   	; 0xc06 <__udivmodhi4>
 150:	80 e0       	ldi	r24, 0x00	; 0
 152:	90 e0       	ldi	r25, 0x00	; 0
 154:	9b 01       	movw	r18, r22
 156:	ac 01       	movw	r20, r24
 158:	e4 e0       	ldi	r30, 0x04	; 4
 15a:	22 0f       	add	r18, r18
 15c:	33 1f       	adc	r19, r19
 15e:	44 1f       	adc	r20, r20
 160:	55 1f       	adc	r21, r21
 162:	ea 95       	dec	r30
 164:	d1 f7       	brne	.-12     	; 0x15a <delay_us+0x12>
 166:	26 1b       	sub	r18, r22
 168:	37 0b       	sbc	r19, r23
 16a:	48 0b       	sbc	r20, r24
 16c:	59 0b       	sbc	r21, r25
 16e:	c9 01       	movw	r24, r18
 170:	96 95       	lsr	r25
 172:	87 95       	ror	r24
 174:	96 95       	lsr	r25
 176:	87 95       	ror	r24
 178:	01 97       	sbiw	r24, 0x01	; 1
 17a:	f1 f7       	brne	.-4      	; 0x178 <delay_us+0x30>
{
    uint16_t dcnt;
    dcnt = (us+3) / 3 * CYCLES_PER_US;
    /* 16-bit count - 4 cycles/loop */
    _delay_loop_2(dcnt / 4);
}
 17c:	08 95       	ret

0000017e <__vector_1>:
/****************************************************************************
 * Change PORT direction based on condition of INT0 Pin (/CS).
 ***************************************************************************/

SIGNAL(SIG_INTERRUPT0)
{
 17e:	1f 92       	push	r1
 180:	0f 92       	push	r0
 182:	0f b6       	in	r0, 0x3f	; 63
 184:	0f 92       	push	r0
 186:	11 24       	eor	r1, r1
 188:	8f 93       	push	r24
    if (PIND & 0x04)        // Chip select line high (not enabled)
 18a:	82 9b       	sbis	0x10, 2	; 16
 18c:	06 c0       	rjmp	.+12     	; 0x19a <__vector_1+0x1c>
    {
        DDRD &= ~0xF0;      // Tri-state the outputs!
 18e:	81 b3       	in	r24, 0x11	; 17
 190:	8f 70       	andi	r24, 0x0F	; 15
 192:	81 bb       	out	0x11, r24	; 17
        s_cs1 = 0;        // chip select CS1/ inactive
 194:	10 92 70 00 	sts	0x0070, r1
 198:	06 c0       	rjmp	.+12     	; 0x1a6 <__vector_1+0x28>
    }
    else                    // Chip select line low (enabled)
    {
        DDRD |= 0xF0;       // Drive the outputs
 19a:	81 b3       	in	r24, 0x11	; 17
 19c:	80 6f       	ori	r24, 0xF0	; 240
 19e:	81 bb       	out	0x11, r24	; 17
        s_cs1 = 1;        // chip select CS1/ active
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	80 93 70 00 	sts	0x0070, r24
    }
}
 1a6:	8f 91       	pop	r24
 1a8:	0f 90       	pop	r0
 1aa:	0f be       	out	0x3f, r0	; 63
 1ac:	0f 90       	pop	r0
 1ae:	1f 90       	pop	r1
 1b0:	18 95       	reti

000001b2 <__vector_9>:
 ***************************************************************************/

#define TICK_RATE_HZ    60UL

SIGNAL(SIG_OVERFLOW0)
{
 1b2:	1f 92       	push	r1
 1b4:	0f 92       	push	r0
 1b6:	0f b6       	in	r0, 0x3f	; 63
 1b8:	0f 92       	push	r0
 1ba:	11 24       	eor	r1, r1
 1bc:	8f 93       	push	r24
    uint16_t cmatch;

    cmatch = (uint16_t)((F_CPU / TICK_RATE_HZ) / 1024UL);

    /* Setup the timer starting value */
    TCNT1L = (uint8_t)cmatch;
 1be:	80 ef       	ldi	r24, 0xF0	; 240
 1c0:	8c bd       	out	0x2c, r24	; 44
    TCNT1H = (uint8_t)(cmatch >> 8);
 1c2:	1d bc       	out	0x2d, r1	; 45

//    PORTB |= _BV(B_LED);
}
 1c4:	8f 91       	pop	r24
 1c6:	0f 90       	pop	r0
 1c8:	0f be       	out	0x3f, r0	; 63
 1ca:	0f 90       	pop	r0
 1cc:	1f 90       	pop	r1
 1ce:	18 95       	reti

000001d0 <tx_packet>:
    return stat;
}


int tx_packet(uint8_t flgcmd, uint8_t bank, uint8_t* data, uint16_t datasize)
{
 1d0:	8f 92       	push	r8
 1d2:	9f 92       	push	r9
 1d4:	af 92       	push	r10
 1d6:	bf 92       	push	r11
 1d8:	df 92       	push	r13
 1da:	ef 92       	push	r14
 1dc:	ff 92       	push	r15
 1de:	0f 93       	push	r16
 1e0:	1f 93       	push	r17
 1e2:	cf 93       	push	r28
 1e4:	df 93       	push	r29
 1e6:	e8 2e       	mov	r14, r24
 1e8:	d6 2e       	mov	r13, r22
 1ea:	4a 01       	movw	r8, r20
 1ec:	59 01       	movw	r10, r18
    uint16_t lsb;
    uint16_t msb;
    uint16_t crc = 0;

    /* Send the SOH first (0) */
    asi_putc(SOH);
 1ee:	81 e0       	ldi	r24, 0x01	; 1
 1f0:	61 d3       	rcall	.+1730   	; 0x8b4 <asi_putc>
    /* Send the length MSB/LSB bytes */
    msb = (uint16_t)datasize >> 4;;
    lsb = (uint16_t)datasize & 0xff;

    /* Send CRC MSB byte (1) */
    crc = _crc_xmodem_update(crc, msb);
 1f2:	c5 01       	movw	r24, r10
 1f4:	a4 e0       	ldi	r26, 0x04	; 4
 1f6:	96 95       	lsr	r25
 1f8:	87 95       	ror	r24
 1fa:	aa 95       	dec	r26
 1fc:	e1 f7       	brne	.-8      	; 0x1f6 <tx_packet+0x26>
    uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
    uint8_t __tmp1;             /* %1 */
    uint8_t __tmp2;             /* %2 */
                                /* %3  __data */

    __asm__ __volatile__ (
 1fe:	c0 e0       	ldi	r28, 0x00	; 0
 200:	d0 e0       	ldi	r29, 0x00	; 0
 202:	d8 27       	eor	r29, r24
 204:	0d 2e       	mov	r0, r29
 206:	02 94       	swap	r0
 208:	90 2d       	mov	r25, r0
 20a:	9f 70       	andi	r25, 0x0F	; 15
 20c:	9d 27       	eor	r25, r29
 20e:	2d 2f       	mov	r18, r29
 210:	20 25       	eor	r18, r0
 212:	22 0f       	add	r18, r18
 214:	20 7e       	andi	r18, 0xE0	; 224
 216:	92 27       	eor	r25, r18
 218:	20 2d       	mov	r18, r0
 21a:	2d 27       	eor	r18, r29
 21c:	20 7f       	andi	r18, 0xF0	; 240
 21e:	26 95       	lsr	r18
 220:	0d 2e       	mov	r0, r29
 222:	00 0c       	add	r0, r0
 224:	22 1f       	adc	r18, r18
 226:	d6 95       	lsr	r29
 228:	d6 95       	lsr	r29
 22a:	d6 95       	lsr	r29
 22c:	df 71       	andi	r29, 0x1F	; 31
 22e:	d2 27       	eor	r29, r18
 230:	dc 27       	eor	r29, r28
 232:	c9 2f       	mov	r28, r25
    asi_putc(msb);
 234:	3f d3       	rcall	.+1662   	; 0x8b4 <asi_putc>

    /* Send CRC LSB byte (2) */
    crc = _crc_xmodem_update(crc, lsb);
 236:	c5 01       	movw	r24, r10
 238:	90 70       	andi	r25, 0x00	; 0
 23a:	f8 2e       	mov	r15, r24
 23c:	d8 27       	eor	r29, r24
 23e:	0d 2e       	mov	r0, r29
 240:	02 94       	swap	r0
 242:	90 2d       	mov	r25, r0
 244:	9f 70       	andi	r25, 0x0F	; 15
 246:	9d 27       	eor	r25, r29
 248:	2d 2f       	mov	r18, r29
 24a:	20 25       	eor	r18, r0
 24c:	22 0f       	add	r18, r18
 24e:	20 7e       	andi	r18, 0xE0	; 224
 250:	92 27       	eor	r25, r18
 252:	20 2d       	mov	r18, r0
 254:	2d 27       	eor	r18, r29
 256:	20 7f       	andi	r18, 0xF0	; 240
 258:	26 95       	lsr	r18
 25a:	0d 2e       	mov	r0, r29
 25c:	00 0c       	add	r0, r0
 25e:	22 1f       	adc	r18, r18
 260:	d6 95       	lsr	r29
 262:	d6 95       	lsr	r29
 264:	d6 95       	lsr	r29
 266:	df 71       	andi	r29, 0x1F	; 31
 268:	d2 27       	eor	r29, r18
 26a:	dc 27       	eor	r29, r28
 26c:	c9 2f       	mov	r28, r25
    asi_putc(lsb);
 26e:	22 d3       	rcall	.+1604   	; 0x8b4 <asi_putc>

    /* Send the FLG/CMD byte (3) */
    crc = _crc_xmodem_update(flgcmd, lsb);
 270:	0e 2d       	mov	r16, r14
 272:	10 e0       	ldi	r17, 0x00	; 0
 274:	c8 01       	movw	r24, r16
 276:	9f 25       	eor	r25, r15
 278:	09 2e       	mov	r0, r25
 27a:	02 94       	swap	r0
 27c:	20 2d       	mov	r18, r0
 27e:	2f 70       	andi	r18, 0x0F	; 15
 280:	29 27       	eor	r18, r25
 282:	39 2f       	mov	r19, r25
 284:	30 25       	eor	r19, r0
 286:	33 0f       	add	r19, r19
 288:	30 7e       	andi	r19, 0xE0	; 224
 28a:	23 27       	eor	r18, r19
 28c:	30 2d       	mov	r19, r0
 28e:	39 27       	eor	r19, r25
 290:	30 7f       	andi	r19, 0xF0	; 240
 292:	36 95       	lsr	r19
 294:	09 2e       	mov	r0, r25
 296:	00 0c       	add	r0, r0
 298:	33 1f       	adc	r19, r19
 29a:	96 95       	lsr	r25
 29c:	96 95       	lsr	r25
 29e:	96 95       	lsr	r25
 2a0:	9f 71       	andi	r25, 0x1F	; 31
 2a2:	93 27       	eor	r25, r19
 2a4:	98 27       	eor	r25, r24
 2a6:	82 2f       	mov	r24, r18
    asi_putc(flgcmd);
 2a8:	8e 2d       	mov	r24, r14
 2aa:	04 d3       	rcall	.+1544   	; 0x8b4 <asi_putc>
 2ac:	1d 25       	eor	r17, r13
 2ae:	01 2e       	mov	r0, r17
 2b0:	02 94       	swap	r0
 2b2:	80 2d       	mov	r24, r0
 2b4:	8f 70       	andi	r24, 0x0F	; 15
 2b6:	81 27       	eor	r24, r17
 2b8:	91 2f       	mov	r25, r17
 2ba:	90 25       	eor	r25, r0
 2bc:	99 0f       	add	r25, r25
 2be:	90 7e       	andi	r25, 0xE0	; 224
 2c0:	89 27       	eor	r24, r25
 2c2:	90 2d       	mov	r25, r0
 2c4:	91 27       	eor	r25, r17
 2c6:	90 7f       	andi	r25, 0xF0	; 240
 2c8:	96 95       	lsr	r25
 2ca:	01 2e       	mov	r0, r17
 2cc:	00 0c       	add	r0, r0
 2ce:	99 1f       	adc	r25, r25
 2d0:	16 95       	lsr	r17
 2d2:	16 95       	lsr	r17
 2d4:	16 95       	lsr	r17
 2d6:	1f 71       	andi	r17, 0x1F	; 31
 2d8:	19 27       	eor	r17, r25
 2da:	10 27       	eor	r17, r16
 2dc:	08 2f       	mov	r16, r24

    /* Send the BANK# byte (4) */
    crc = _crc_xmodem_update(flgcmd, bank);
    asi_putc(bank);
 2de:	8d 2d       	mov	r24, r13
 2e0:	e9 d2       	rcall	.+1490   	; 0x8b4 <asi_putc>

    /* Send any DATA payload */
    if (data && datasize)
 2e2:	81 14       	cp	r8, r1
 2e4:	91 04       	cpc	r9, r1
 2e6:	09 f4       	brne	.+2      	; 0x2ea <tx_packet+0x11a>
 2e8:	29 c0       	rjmp	.+82     	; 0x33c <tx_packet+0x16c>
 2ea:	a1 14       	cp	r10, r1
 2ec:	b1 04       	cpc	r11, r1
 2ee:	09 f4       	brne	.+2      	; 0x2f2 <tx_packet+0x122>
 2f0:	25 c0       	rjmp	.+74     	; 0x33c <tx_packet+0x16c>
 2f2:	c0 e0       	ldi	r28, 0x00	; 0
 2f4:	d0 e0       	ldi	r29, 0x00	; 0
 2f6:	1f c0       	rjmp	.+62     	; 0x336 <tx_packet+0x166>
    {
        for (i=0; i < datasize; i++)
        {
            crc = _crc_xmodem_update(crc, data[i]);
 2f8:	f4 01       	movw	r30, r8
 2fa:	ec 0f       	add	r30, r28
 2fc:	fd 1f       	adc	r31, r29
 2fe:	80 81       	ld	r24, Z
 300:	18 27       	eor	r17, r24
 302:	01 2e       	mov	r0, r17
 304:	02 94       	swap	r0
 306:	90 2d       	mov	r25, r0
 308:	9f 70       	andi	r25, 0x0F	; 15
 30a:	91 27       	eor	r25, r17
 30c:	21 2f       	mov	r18, r17
 30e:	20 25       	eor	r18, r0
 310:	22 0f       	add	r18, r18
 312:	20 7e       	andi	r18, 0xE0	; 224
 314:	92 27       	eor	r25, r18
 316:	20 2d       	mov	r18, r0
 318:	21 27       	eor	r18, r17
 31a:	20 7f       	andi	r18, 0xF0	; 240
 31c:	26 95       	lsr	r18
 31e:	01 2e       	mov	r0, r17
 320:	00 0c       	add	r0, r0
 322:	22 1f       	adc	r18, r18
 324:	16 95       	lsr	r17
 326:	16 95       	lsr	r17
 328:	16 95       	lsr	r17
 32a:	1f 71       	andi	r17, 0x1F	; 31
 32c:	12 27       	eor	r17, r18
 32e:	10 27       	eor	r17, r16
 330:	09 2f       	mov	r16, r25
            asi_putc(data[i]);
 332:	c0 d2       	rcall	.+1408   	; 0x8b4 <asi_putc>
    asi_putc(bank);

    /* Send any DATA payload */
    if (data && datasize)
    {
        for (i=0; i < datasize; i++)
 334:	21 96       	adiw	r28, 0x01	; 1
 336:	ca 15       	cp	r28, r10
 338:	db 05       	cpc	r29, r11
 33a:	f0 f2       	brcs	.-68     	; 0x2f8 <tx_packet+0x128>
            asi_putc(data[i]);
        }
    }

    /* Send the CRC MSB */
    asi_putc((int)(crc >> 4) & 0xff);
 33c:	c8 01       	movw	r24, r16
 33e:	f4 e0       	ldi	r31, 0x04	; 4
 340:	96 95       	lsr	r25
 342:	87 95       	ror	r24
 344:	fa 95       	dec	r31
 346:	e1 f7       	brne	.-8      	; 0x340 <tx_packet+0x170>
 348:	b5 d2       	rcall	.+1386   	; 0x8b4 <asi_putc>

    /* Send the CRC LSB */
    asi_putc((int)crc & 0xff);
 34a:	80 2f       	mov	r24, r16
 34c:	b3 d2       	rcall	.+1382   	; 0x8b4 <asi_putc>

    return 0;
}
 34e:	80 e0       	ldi	r24, 0x00	; 0
 350:	90 e0       	ldi	r25, 0x00	; 0
 352:	df 91       	pop	r29
 354:	cf 91       	pop	r28
 356:	1f 91       	pop	r17
 358:	0f 91       	pop	r16
 35a:	ff 90       	pop	r15
 35c:	ef 90       	pop	r14
 35e:	df 90       	pop	r13
 360:	bf 90       	pop	r11
 362:	af 90       	pop	r10
 364:	9f 90       	pop	r9
 366:	8f 90       	pop	r8
 368:	08 95       	ret

0000036a <rx_packet>:
/* Attempt to receive a serial command packet from the host (GE-Flash).
 * If we get a valid packet then decode the command and process it.
 */

int rx_packet(void)
{
 36a:	cf 92       	push	r12
 36c:	df 92       	push	r13
 36e:	ef 92       	push	r14
 370:	ff 92       	push	r15
 372:	0f 93       	push	r16
 374:	1f 93       	push	r17
 376:	cf 93       	push	r28
 378:	df 93       	push	r29
    uint16_t    crc_packet;

    crc = 0;

    /* Read the SOH first (wait up to 5 seconds) */
    if ((c = asi_tgetc(500)) == -1)
 37a:	84 ef       	ldi	r24, 0xF4	; 244
 37c:	91 e0       	ldi	r25, 0x01	; 1
 37e:	8f d3       	rcall	.+1822   	; 0xa9e <asi_tgetc>
 380:	2f ef       	ldi	r18, 0xFF	; 255
 382:	8f 3f       	cpi	r24, 0xFF	; 255
 384:	92 07       	cpc	r25, r18
 386:	19 f4       	brne	.+6      	; 0x38e <rx_packet+0x24>
 388:	21 e0       	ldi	r18, 0x01	; 1
 38a:	30 e0       	ldi	r19, 0x00	; 0
 38c:	97 c1       	rjmp	.+814    	; 0x6bc <__stack+0x25d>
        return 1;
    if (c != SOH)
 38e:	01 97       	sbiw	r24, 0x01	; 1
 390:	19 f0       	breq	.+6      	; 0x398 <rx_packet+0x2e>
 392:	22 e0       	ldi	r18, 0x02	; 2
 394:	30 e0       	ldi	r19, 0x00	; 0
 396:	92 c1       	rjmp	.+804    	; 0x6bc <__stack+0x25d>
        return 2;

    // Read 'len_msb' byte
    if ((c = asi_tgetc(100)) == -1)
 398:	84 e6       	ldi	r24, 0x64	; 100
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	80 d3       	rcall	.+1792   	; 0xa9e <asi_tgetc>
 39e:	7c 01       	movw	r14, r24
 3a0:	4f ef       	ldi	r20, 0xFF	; 255
 3a2:	8f 3f       	cpi	r24, 0xFF	; 255
 3a4:	94 07       	cpc	r25, r20
 3a6:	19 f4       	brne	.+6      	; 0x3ae <rx_packet+0x44>
 3a8:	23 e0       	ldi	r18, 0x03	; 3
 3aa:	30 e0       	ldi	r19, 0x00	; 0
 3ac:	87 c1       	rjmp	.+782    	; 0x6bc <__stack+0x25d>
 3ae:	c0 e0       	ldi	r28, 0x00	; 0
 3b0:	d0 e0       	ldi	r29, 0x00	; 0
 3b2:	d8 27       	eor	r29, r24
 3b4:	0d 2e       	mov	r0, r29
 3b6:	02 94       	swap	r0
 3b8:	80 2d       	mov	r24, r0
 3ba:	8f 70       	andi	r24, 0x0F	; 15
 3bc:	8d 27       	eor	r24, r29
 3be:	9d 2f       	mov	r25, r29
 3c0:	90 25       	eor	r25, r0
 3c2:	99 0f       	add	r25, r25
 3c4:	90 7e       	andi	r25, 0xE0	; 224
 3c6:	89 27       	eor	r24, r25
 3c8:	90 2d       	mov	r25, r0
 3ca:	9d 27       	eor	r25, r29
 3cc:	90 7f       	andi	r25, 0xF0	; 240
 3ce:	96 95       	lsr	r25
 3d0:	0d 2e       	mov	r0, r29
 3d2:	00 0c       	add	r0, r0
 3d4:	99 1f       	adc	r25, r25
 3d6:	d6 95       	lsr	r29
 3d8:	d6 95       	lsr	r29
 3da:	d6 95       	lsr	r29
 3dc:	df 71       	andi	r29, 0x1F	; 31
 3de:	d9 27       	eor	r29, r25
 3e0:	dc 27       	eor	r29, r28
 3e2:	c8 2f       	mov	r28, r24
        return 3;
    crc = _crc_xmodem_update(crc, c);
    msb = (uint16_t)c;

    // Read 'len_lsb' byte
    if ((c = asi_tgetc(100)) == -1)
 3e4:	84 e6       	ldi	r24, 0x64	; 100
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	5a d3       	rcall	.+1716   	; 0xa9e <asi_tgetc>
 3ea:	8c 01       	movw	r16, r24
 3ec:	5f ef       	ldi	r21, 0xFF	; 255
 3ee:	8f 3f       	cpi	r24, 0xFF	; 255
 3f0:	95 07       	cpc	r25, r21
 3f2:	19 f4       	brne	.+6      	; 0x3fa <rx_packet+0x90>
 3f4:	24 e0       	ldi	r18, 0x04	; 4
 3f6:	30 e0       	ldi	r19, 0x00	; 0
 3f8:	61 c1       	rjmp	.+706    	; 0x6bc <__stack+0x25d>
 3fa:	d8 27       	eor	r29, r24
 3fc:	0d 2e       	mov	r0, r29
 3fe:	02 94       	swap	r0
 400:	80 2d       	mov	r24, r0
 402:	8f 70       	andi	r24, 0x0F	; 15
 404:	8d 27       	eor	r24, r29
 406:	9d 2f       	mov	r25, r29
 408:	90 25       	eor	r25, r0
 40a:	99 0f       	add	r25, r25
 40c:	90 7e       	andi	r25, 0xE0	; 224
 40e:	89 27       	eor	r24, r25
 410:	90 2d       	mov	r25, r0
 412:	9d 27       	eor	r25, r29
 414:	90 7f       	andi	r25, 0xF0	; 240
 416:	96 95       	lsr	r25
 418:	0d 2e       	mov	r0, r29
 41a:	00 0c       	add	r0, r0
 41c:	99 1f       	adc	r25, r25
 41e:	d6 95       	lsr	r29
 420:	d6 95       	lsr	r29
 422:	d6 95       	lsr	r29
 424:	df 71       	andi	r29, 0x1F	; 31
 426:	d9 27       	eor	r29, r25
 428:	dc 27       	eor	r29, r28
 42a:	c8 2f       	mov	r28, r24
    crc = _crc_xmodem_update(crc, c);
    lsb = (uint16_t)c;
    len = (msb << 8) | lsb;

    // Read 'flgs/cmd' byte
    if ((c = asi_tgetc(100)) == -1)
 42c:	84 e6       	ldi	r24, 0x64	; 100
 42e:	90 e0       	ldi	r25, 0x00	; 0
 430:	36 d3       	rcall	.+1644   	; 0xa9e <asi_tgetc>
 432:	2f ef       	ldi	r18, 0xFF	; 255
 434:	8f 3f       	cpi	r24, 0xFF	; 255
 436:	92 07       	cpc	r25, r18
 438:	19 f4       	brne	.+6      	; 0x440 <rx_packet+0xd6>
 43a:	25 e0       	ldi	r18, 0x05	; 5
 43c:	30 e0       	ldi	r19, 0x00	; 0
 43e:	3e c1       	rjmp	.+636    	; 0x6bc <__stack+0x25d>
        return 5;
    crc = _crc_xmodem_update(crc, c);
 440:	d8 2e       	mov	r13, r24
 442:	d8 27       	eor	r29, r24
 444:	0d 2e       	mov	r0, r29
 446:	02 94       	swap	r0
 448:	80 2d       	mov	r24, r0
 44a:	8f 70       	andi	r24, 0x0F	; 15
 44c:	8d 27       	eor	r24, r29
 44e:	9d 2f       	mov	r25, r29
 450:	90 25       	eor	r25, r0
 452:	99 0f       	add	r25, r25
 454:	90 7e       	andi	r25, 0xE0	; 224
 456:	89 27       	eor	r24, r25
 458:	90 2d       	mov	r25, r0
 45a:	9d 27       	eor	r25, r29
 45c:	90 7f       	andi	r25, 0xF0	; 240
 45e:	96 95       	lsr	r25
 460:	0d 2e       	mov	r0, r29
 462:	00 0c       	add	r0, r0
 464:	99 1f       	adc	r25, r25
 466:	d6 95       	lsr	r29
 468:	d6 95       	lsr	r29
 46a:	d6 95       	lsr	r29
 46c:	df 71       	andi	r29, 0x1F	; 31
 46e:	d9 27       	eor	r29, r25
 470:	dc 27       	eor	r29, r28
 472:	c8 2f       	mov	r28, r24
    flgcmd = (uint16_t)c;

    // Read 'bank#' byte state
    if ((c = asi_tgetc(100)) == -1)
 474:	84 e6       	ldi	r24, 0x64	; 100
 476:	90 e0       	ldi	r25, 0x00	; 0
 478:	12 d3       	rcall	.+1572   	; 0xa9e <asi_tgetc>
 47a:	4f ef       	ldi	r20, 0xFF	; 255
 47c:	8f 3f       	cpi	r24, 0xFF	; 255
 47e:	94 07       	cpc	r25, r20
 480:	19 f4       	brne	.+6      	; 0x488 <__stack+0x29>
 482:	26 e0       	ldi	r18, 0x06	; 6
 484:	30 e0       	ldi	r19, 0x00	; 0
 486:	1a c1       	rjmp	.+564    	; 0x6bc <__stack+0x25d>
    // Read 'len_lsb' byte
    if ((c = asi_tgetc(100)) == -1)
        return 4;
    crc = _crc_xmodem_update(crc, c);
    lsb = (uint16_t)c;
    len = (msb << 8) | lsb;
 488:	fe 2c       	mov	r15, r14
 48a:	ee 24       	eor	r14, r14
 48c:	e0 2a       	or	r14, r16
 48e:	f1 2a       	or	r15, r17
    flgcmd = (uint16_t)c;

    // Read 'bank#' byte state
    if ((c = asi_tgetc(100)) == -1)
        return 6;
    crc = _crc_xmodem_update(crc, c);
 490:	c8 2e       	mov	r12, r24
 492:	d8 27       	eor	r29, r24
 494:	0d 2e       	mov	r0, r29
 496:	02 94       	swap	r0
 498:	80 2d       	mov	r24, r0
 49a:	8f 70       	andi	r24, 0x0F	; 15
 49c:	8d 27       	eor	r24, r29
 49e:	9d 2f       	mov	r25, r29
 4a0:	90 25       	eor	r25, r0
 4a2:	99 0f       	add	r25, r25
 4a4:	90 7e       	andi	r25, 0xE0	; 224
 4a6:	89 27       	eor	r24, r25
 4a8:	90 2d       	mov	r25, r0
 4aa:	9d 27       	eor	r25, r29
 4ac:	90 7f       	andi	r25, 0xF0	; 240
 4ae:	96 95       	lsr	r25
 4b0:	0d 2e       	mov	r0, r29
 4b2:	00 0c       	add	r0, r0
 4b4:	99 1f       	adc	r25, r25
 4b6:	d6 95       	lsr	r29
 4b8:	d6 95       	lsr	r29
 4ba:	d6 95       	lsr	r29
 4bc:	df 71       	andi	r29, 0x1F	; 31
 4be:	d9 27       	eor	r29, r25
 4c0:	dc 27       	eor	r29, r28
 4c2:	c8 2f       	mov	r28, r24
    banknum = (uint16_t)c & 0x1;

    // frame length validation
    if (len > 256)
 4c4:	51 e0       	ldi	r21, 0x01	; 1
 4c6:	e5 16       	cp	r14, r21
 4c8:	51 e0       	ldi	r21, 0x01	; 1
 4ca:	f5 06       	cpc	r15, r21
 4cc:	18 f0       	brcs	.+6      	; 0x4d4 <__stack+0x75>
 4ce:	27 e0       	ldi	r18, 0x07	; 7
 4d0:	30 e0       	ldi	r19, 0x00	; 0
 4d2:	f4 c0       	rjmp	.+488    	; 0x6bc <__stack+0x25d>
 4d4:	00 e0       	ldi	r16, 0x00	; 0
 4d6:	10 e0       	ldi	r17, 0x00	; 0
 4d8:	29 c0       	rjmp	.+82     	; 0x52c <__stack+0xcd>

    // Read any data for length specified
    for (i=0; i < len; i++)
    {
        // Read a byte of data from the stream
        if ((c = asi_tgetc(100)) == -1)
 4da:	84 e6       	ldi	r24, 0x64	; 100
 4dc:	90 e0       	ldi	r25, 0x00	; 0
 4de:	df d2       	rcall	.+1470   	; 0xa9e <asi_tgetc>
 4e0:	2f ef       	ldi	r18, 0xFF	; 255
 4e2:	8f 3f       	cpi	r24, 0xFF	; 255
 4e4:	92 07       	cpc	r25, r18
 4e6:	19 f4       	brne	.+6      	; 0x4ee <__stack+0x8f>
 4e8:	28 e0       	ldi	r18, 0x08	; 8
 4ea:	30 e0       	ldi	r19, 0x00	; 0
 4ec:	e7 c0       	rjmp	.+462    	; 0x6bc <__stack+0x25d>
 4ee:	d8 27       	eor	r29, r24
 4f0:	0d 2e       	mov	r0, r29
 4f2:	02 94       	swap	r0
 4f4:	20 2d       	mov	r18, r0
 4f6:	2f 70       	andi	r18, 0x0F	; 15
 4f8:	2d 27       	eor	r18, r29
 4fa:	3d 2f       	mov	r19, r29
 4fc:	30 25       	eor	r19, r0
 4fe:	33 0f       	add	r19, r19
 500:	30 7e       	andi	r19, 0xE0	; 224
 502:	23 27       	eor	r18, r19
 504:	30 2d       	mov	r19, r0
 506:	3d 27       	eor	r19, r29
 508:	30 7f       	andi	r19, 0xF0	; 240
 50a:	36 95       	lsr	r19
 50c:	0d 2e       	mov	r0, r29
 50e:	00 0c       	add	r0, r0
 510:	33 1f       	adc	r19, r19
 512:	d6 95       	lsr	r29
 514:	d6 95       	lsr	r29
 516:	d6 95       	lsr	r29
 518:	df 71       	andi	r29, 0x1F	; 31
 51a:	d3 27       	eor	r29, r19
 51c:	dc 27       	eor	r29, r28
 51e:	c2 2f       	mov	r28, r18
            return 8;
        // Update CRC with the data byte
        crc = _crc_xmodem_update(crc, c);
        // Store it in the rx frame buffer
        s_frame[i] = c;
 520:	f8 01       	movw	r30, r16
 522:	ee 54       	subi	r30, 0x4E	; 78
 524:	fd 4f       	sbci	r31, 0xFD	; 253
 526:	80 83       	st	Z, r24
    // frame length validation
    if (len > 256)
        return 7;

    // Read any data for length specified
    for (i=0; i < len; i++)
 528:	0f 5f       	subi	r16, 0xFF	; 255
 52a:	1f 4f       	sbci	r17, 0xFF	; 255
 52c:	0e 15       	cp	r16, r14
 52e:	1f 05       	cpc	r17, r15
 530:	08 f4       	brcc	.+2      	; 0x534 <__stack+0xd5>
 532:	d3 cf       	rjmp	.-90     	; 0x4da <__stack+0x7b>
 534:	20 e0       	ldi	r18, 0x00	; 0
 536:	ce 01       	movw	r24, r28
 538:	92 27       	eor	r25, r18
 53a:	09 2e       	mov	r0, r25
 53c:	02 94       	swap	r0
 53e:	30 2d       	mov	r19, r0
 540:	3f 70       	andi	r19, 0x0F	; 15
 542:	39 27       	eor	r19, r25
 544:	49 2f       	mov	r20, r25
 546:	40 25       	eor	r20, r0
 548:	44 0f       	add	r20, r20
 54a:	40 7e       	andi	r20, 0xE0	; 224
 54c:	34 27       	eor	r19, r20
 54e:	40 2d       	mov	r20, r0
 550:	49 27       	eor	r20, r25
 552:	40 7f       	andi	r20, 0xF0	; 240
 554:	46 95       	lsr	r20
 556:	09 2e       	mov	r0, r25
 558:	00 0c       	add	r0, r0
 55a:	44 1f       	adc	r20, r20
 55c:	96 95       	lsr	r25
 55e:	96 95       	lsr	r25
 560:	96 95       	lsr	r25
 562:	9f 71       	andi	r25, 0x1F	; 31
 564:	94 27       	eor	r25, r20
 566:	98 27       	eor	r25, r24
 568:	83 2f       	mov	r24, r19

    /* final CRC calculation */
    crc = _crc_xmodem_update(_crc_xmodem_update(crc,0),0);

    // Read CRC MSB byte
    if ((msb = asi_tgetc(100)) == -1)
 56a:	ac 01       	movw	r20, r24
 56c:	52 27       	eor	r21, r18
 56e:	05 2e       	mov	r0, r21
 570:	02 94       	swap	r0
 572:	80 2d       	mov	r24, r0
 574:	8f 70       	andi	r24, 0x0F	; 15
 576:	85 27       	eor	r24, r21
 578:	95 2f       	mov	r25, r21
 57a:	90 25       	eor	r25, r0
 57c:	99 0f       	add	r25, r25
 57e:	90 7e       	andi	r25, 0xE0	; 224
 580:	89 27       	eor	r24, r25
 582:	90 2d       	mov	r25, r0
 584:	95 27       	eor	r25, r21
 586:	90 7f       	andi	r25, 0xF0	; 240
 588:	96 95       	lsr	r25
 58a:	05 2e       	mov	r0, r21
 58c:	00 0c       	add	r0, r0
 58e:	99 1f       	adc	r25, r25
 590:	56 95       	lsr	r21
 592:	56 95       	lsr	r21
 594:	56 95       	lsr	r21
 596:	5f 71       	andi	r21, 0x1F	; 31
 598:	59 27       	eor	r21, r25
 59a:	54 27       	eor	r21, r20
 59c:	48 2f       	mov	r20, r24
 59e:	7a 01       	movw	r14, r20
 5a0:	84 e6       	ldi	r24, 0x64	; 100
 5a2:	90 e0       	ldi	r25, 0x00	; 0
 5a4:	7c d2       	rcall	.+1272   	; 0xa9e <asi_tgetc>
 5a6:	8c 01       	movw	r16, r24
 5a8:	5f ef       	ldi	r21, 0xFF	; 255
 5aa:	8f 3f       	cpi	r24, 0xFF	; 255
 5ac:	95 07       	cpc	r25, r21
 5ae:	19 f4       	brne	.+6      	; 0x5b6 <__stack+0x157>
 5b0:	29 e0       	ldi	r18, 0x09	; 9
 5b2:	30 e0       	ldi	r19, 0x00	; 0
 5b4:	83 c0       	rjmp	.+262    	; 0x6bc <__stack+0x25d>
        return 9;

    if ((lsb = asi_tgetc(100)) == -1)
 5b6:	84 e6       	ldi	r24, 0x64	; 100
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	71 d2       	rcall	.+1250   	; 0xa9e <asi_tgetc>
 5bc:	ec 01       	movw	r28, r24
 5be:	8f ef       	ldi	r24, 0xFF	; 255
 5c0:	cf 3f       	cpi	r28, 0xFF	; 255
 5c2:	d8 07       	cpc	r29, r24
 5c4:	19 f4       	brne	.+6      	; 0x5cc <__stack+0x16d>
 5c6:	2a e0       	ldi	r18, 0x0A	; 10
 5c8:	30 e0       	ldi	r19, 0x00	; 0
 5ca:	78 c0       	rjmp	.+240    	; 0x6bc <__stack+0x25d>

    // Get the packet CRC value
    crc_packet = (msb << 8) | lsb;

    // Check if the CRC's match
    if (crc != crc_packet)
 5cc:	90 2f       	mov	r25, r16
 5ce:	88 27       	eor	r24, r24
 5d0:	8c 2b       	or	r24, r28
 5d2:	9d 2b       	or	r25, r29
 5d4:	e8 16       	cp	r14, r24
 5d6:	f9 06       	cpc	r15, r25
 5d8:	11 f0       	breq	.+4      	; 0x5de <__stack+0x17f>
    {
        asi_putc(NAK);
 5da:	85 e1       	ldi	r24, 0x15	; 21
 5dc:	2b c0       	rjmp	.+86     	; 0x634 <__stack+0x1d5>

    // Read 'bank#' byte state
    if ((c = asi_tgetc(100)) == -1)
        return 6;
    crc = _crc_xmodem_update(crc, c);
    banknum = (uint16_t)c & 0x1;
 5de:	6c 2d       	mov	r22, r12
 5e0:	61 70       	andi	r22, 0x01	; 1

    /* VALID FRAME RECEIVED - DECODE THE COMMAND */

    stat = 0;

    switch(flgcmd & 0x0F)
 5e2:	8d 2d       	mov	r24, r13
 5e4:	90 e0       	ldi	r25, 0x00	; 0
 5e6:	8f 70       	andi	r24, 0x0F	; 15
 5e8:	90 70       	andi	r25, 0x00	; 0
 5ea:	81 30       	cpi	r24, 0x01	; 1
 5ec:	91 05       	cpc	r25, r1
 5ee:	21 f0       	breq	.+8      	; 0x5f8 <__stack+0x199>
 5f0:	02 97       	sbiw	r24, 0x02	; 2
 5f2:	09 f0       	breq	.+2      	; 0x5f6 <__stack+0x197>
 5f4:	61 c0       	rjmp	.+194    	; 0x6b8 <__stack+0x259>
 5f6:	41 c0       	rjmp	.+130    	; 0x67a <__stack+0x21b>
 5f8:	a2 eb       	ldi	r26, 0xB2	; 178
 5fa:	b2 e0       	ldi	r27, 0x02	; 2
            break;

        case VXCMD_WRITE_BANK:
            /* Patch downloaded data to correct for mirrored data lines */
            for (i=0; i < BANKSIZE; i++)
                s_frame[i] = s_xbit[s_frame[i] & 0x0f];
 5fc:	ec 91       	ld	r30, X
 5fe:	f0 e0       	ldi	r31, 0x00	; 0
 600:	ef 70       	andi	r30, 0x0F	; 15
 602:	f0 70       	andi	r31, 0x00	; 0
 604:	e0 5a       	subi	r30, 0xA0	; 160
 606:	ff 4f       	sbci	r31, 0xFF	; 255
 608:	80 81       	ld	r24, Z
 60a:	8d 93       	st	X+, r24
        case VXCMD_PING:
            break;

        case VXCMD_WRITE_BANK:
            /* Patch downloaded data to correct for mirrored data lines */
            for (i=0; i < BANKSIZE; i++)
 60c:	23 e0       	ldi	r18, 0x03	; 3
 60e:	a2 3b       	cpi	r26, 0xB2	; 178
 610:	b2 07       	cpc	r27, r18
 612:	a1 f7       	brne	.-24     	; 0x5fc <__stack+0x19d>
                s_frame[i] = s_xbit[s_frame[i] & 0x0f];

            /* Copy from temp rx buffer to active emulation buffer */
            memcpy(&s_bank[banknum * BANKSIZE], s_frame, BANKSIZE);
 614:	96 2f       	mov	r25, r22
 616:	80 e0       	ldi	r24, 0x00	; 0
 618:	dc 01       	movw	r26, r24
 61a:	ae 54       	subi	r26, 0x4E	; 78
 61c:	bf 4f       	sbci	r27, 0xFF	; 255
 61e:	e2 eb       	ldi	r30, 0xB2	; 178
 620:	f2 e0       	ldi	r31, 0x02	; 2
 622:	80 e0       	ldi	r24, 0x00	; 0
 624:	91 e0       	ldi	r25, 0x01	; 1
 626:	01 90       	ld	r0, Z+
 628:	0d 92       	st	X+, r0
 62a:	01 97       	sbiw	r24, 0x01	; 1
 62c:	e1 f7       	brne	.-8      	; 0x626 <__stack+0x1c7>

            /* Test to see if this is the last packet or MORE are to follow */
            if (flgcmd & F_VXCMD_MORE)
 62e:	d7 fe       	sbrs	r13, 7
 630:	07 c0       	rjmp	.+14     	; 0x640 <__stack+0x1e1>
            {
                /* More packets will follow this one.. */
                /* Tell host we stored the bank */
                asi_putc(ACK);
 632:	86 e0       	ldi	r24, 0x06	; 6
 634:	3f d1       	rcall	.+638    	; 0x8b4 <asi_putc>
                asi_putc(msb);
 636:	80 2f       	mov	r24, r16
 638:	3d d1       	rcall	.+634    	; 0x8b4 <asi_putc>
                asi_putc(lsb);
 63a:	8c 2f       	mov	r24, r28
 63c:	3b d1       	rcall	.+630    	; 0x8b4 <asi_putc>
 63e:	3c c0       	rjmp	.+120    	; 0x6b8 <__stack+0x259>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
 640:	80 e0       	ldi	r24, 0x00	; 0
 642:	90 e0       	ldi	r25, 0x00	; 0
 644:	62 eb       	ldi	r22, 0xB2	; 178
 646:	70 e0       	ldi	r23, 0x00	; 0
 648:	40 e0       	ldi	r20, 0x00	; 0
 64a:	52 e0       	ldi	r21, 0x02	; 2
 64c:	2e e4       	ldi	r18, 0x4E	; 78
 64e:	30 e0       	ldi	r19, 0x00	; 0
 650:	c0 d2       	rcall	.+1408   	; 0xbd2 <__eewr_block>
            else
            {
                /* Save the new data to our EPROM */
                eeprom_write_block(s_bank, 0, BANKSIZE * MAX_BANKS);
                /* Tell host we stored the bank */
                asi_putc(ACK);
 652:	86 e0       	ldi	r24, 0x06	; 6
 654:	2f d1       	rcall	.+606    	; 0x8b4 <asi_putc>
                asi_putc(msb);
 656:	80 2f       	mov	r24, r16
 658:	2d d1       	rcall	.+602    	; 0x8b4 <asi_putc>
                asi_putc(lsb);
 65a:	8c 2f       	mov	r24, r28
 65c:	2b d1       	rcall	.+598    	; 0x8b4 <asi_putc>
                /* Blink the LED 2 times upon completion */
                blink_led(2, 75);
 65e:	82 e0       	ldi	r24, 0x02	; 2
 660:	90 e0       	ldi	r25, 0x00	; 0
 662:	6b e4       	ldi	r22, 0x4B	; 75
 664:	70 e0       	ldi	r23, 0x00	; 0
 666:	2d dd       	rcall	.-1446   	; 0xc2 <blink_led>

/* Issue a reset pulse to the radio CPU */

void reset_radio(void)
{
    PORTB |= _BV(B_RRST);
 668:	c2 9a       	sbi	0x18, 2	; 24
 66a:	84 ef       	ldi	r24, 0xF4	; 244
 66c:	91 e0       	ldi	r25, 0x01	; 1
 66e:	01 97       	sbiw	r24, 0x01	; 1
 670:	f1 f7       	brne	.-4      	; 0x66e <__stack+0x20f>
    /* ~100us */
    _delay_loop_2(5*100);
    PORTB &= ~(_BV(B_RRST));
 672:	c2 98       	cbi	0x18, 2	; 24
 674:	2f ef       	ldi	r18, 0xFF	; 255
 676:	3f ef       	ldi	r19, 0xFF	; 255
 678:	21 c0       	rjmp	.+66     	; 0x6bc <__stack+0x25d>
            }
            break;

        case VXCMD_READ_BANK:
            /* Copy from active emulation buffer to tx buffer */
            memcpy(s_frame, &s_bank[banknum * BANKSIZE], BANKSIZE);
 67a:	96 2f       	mov	r25, r22
 67c:	80 e0       	ldi	r24, 0x00	; 0
 67e:	a2 eb       	ldi	r26, 0xB2	; 178
 680:	b2 e0       	ldi	r27, 0x02	; 2
 682:	fc 01       	movw	r30, r24
 684:	ee 54       	subi	r30, 0x4E	; 78
 686:	ff 4f       	sbci	r31, 0xFF	; 255
 688:	80 e0       	ldi	r24, 0x00	; 0
 68a:	91 e0       	ldi	r25, 0x01	; 1
 68c:	01 90       	ld	r0, Z+
 68e:	0d 92       	st	X+, r0
 690:	01 97       	sbiw	r24, 0x01	; 1
 692:	e1 f7       	brne	.-8      	; 0x68c <__stack+0x22d>
 694:	a2 eb       	ldi	r26, 0xB2	; 178
 696:	b2 e0       	ldi	r27, 0x02	; 2

            /* Un-mirror/copy data bits */
            for (i=0; i < BANKSIZE; i++)
                s_frame[i] = s_xbit[s_frame[i]];
 698:	ec 91       	ld	r30, X
 69a:	f0 e0       	ldi	r31, 0x00	; 0
 69c:	e0 5a       	subi	r30, 0xA0	; 160
 69e:	ff 4f       	sbci	r31, 0xFF	; 255
 6a0:	80 81       	ld	r24, Z
 6a2:	8d 93       	st	X+, r24
        case VXCMD_READ_BANK:
            /* Copy from active emulation buffer to tx buffer */
            memcpy(s_frame, &s_bank[banknum * BANKSIZE], BANKSIZE);

            /* Un-mirror/copy data bits */
            for (i=0; i < BANKSIZE; i++)
 6a4:	43 e0       	ldi	r20, 0x03	; 3
 6a6:	a2 3b       	cpi	r26, 0xB2	; 178
 6a8:	b4 07       	cpc	r27, r20
 6aa:	b1 f7       	brne	.-20     	; 0x698 <__stack+0x239>
                s_frame[i] = s_xbit[s_frame[i]];

            /* Send the packet */
            tx_packet(VXCMD_READ_BANK, banknum, s_frame, BANKSIZE);
 6ac:	82 e0       	ldi	r24, 0x02	; 2
 6ae:	42 eb       	ldi	r20, 0xB2	; 178
 6b0:	52 e0       	ldi	r21, 0x02	; 2
 6b2:	20 e0       	ldi	r18, 0x00	; 0
 6b4:	31 e0       	ldi	r19, 0x01	; 1
 6b6:	8c dd       	rcall	.-1256   	; 0x1d0 <tx_packet>
 6b8:	20 e0       	ldi	r18, 0x00	; 0
 6ba:	30 e0       	ldi	r19, 0x00	; 0
        default:
            break;
    }

    return stat;
}
 6bc:	c9 01       	movw	r24, r18
 6be:	df 91       	pop	r29
 6c0:	cf 91       	pop	r28
 6c2:	1f 91       	pop	r17
 6c4:	0f 91       	pop	r16
 6c6:	ff 90       	pop	r15
 6c8:	ef 90       	pop	r14
 6ca:	df 90       	pop	r13
 6cc:	cf 90       	pop	r12
 6ce:	08 95       	ret

000006d0 <main>:
/****************************************************************************
 * MAIN - Program entry at startup.
 ***************************************************************************/

int main(void)
{
 6d0:	df 92       	push	r13
 6d2:	ef 92       	push	r14
 6d4:	ff 92       	push	r15
 6d6:	0f 93       	push	r16
 6d8:	1f 93       	push	r17
 6da:	cf 93       	push	r28
 6dc:	df 93       	push	r29
     * ADC6 = /WE       (in)
     * ADC7 = /STORE    (in)
     */

    /* all pins low */
    PORTC = 0x00;
 6de:	15 ba       	out	0x15, r1	; 21
    /* all pins are input */
    DDRC  = 0x00;
 6e0:	14 ba       	out	0x14, r1	; 20
     * PD6  = D2        (in/out)
     * PD7  = D1        (in/out)
     */

    /* all pins low */
    PORTD = 0x00;
 6e2:	12 ba       	out	0x12, r1	; 18
    /* all pins are input for now */
    DDRD  = 0x00;
 6e4:	11 ba       	out	0x11, r1	; 17
    /* PD1=output, PD4-PD7=output */
    DDRD  = _BV(PD1) | _BV(PD4) | _BV(PD5) | _BV(PD6) | _BV(PD7);
 6e6:	82 ef       	ldi	r24, 0xF2	; 242
 6e8:	81 bb       	out	0x11, r24	; 17
     * PB4  = LED       (out)
     * PB5  = MODE      (in)
     */

    /* all pins low */
    PORTB = 0x00;
 6ea:	18 ba       	out	0x18, r1	; 24
    /* all pins are input for now */
    DDRB  = 0x00;
 6ec:	17 ba       	out	0x17, r1	; 23
    /* PB2-PB4=output, PB0, PB1 & PB5 are input */
    DDRB  = _BV(PB2) | _BV(PB3) | _BV(PB4);
 6ee:	8c e1       	ldi	r24, 0x1C	; 28
 6f0:	87 bb       	out	0x17, r24	; 23

    /* Setup default I/O pins and assignments */
    init_io();

    /* Initialize the USART serial port driver */
    asi_init();
 6f2:	63 d0       	rcall	.+198    	; 0x7ba <asi_init>

    asi_putc('<');
 6f4:	8c e3       	ldi	r24, 0x3C	; 60
 6f6:	de d0       	rcall	.+444    	; 0x8b4 <asi_putc>

    /* Blink the LED 1 or 2 times at power up to 
     * indicate the MODE jumper JP2 select state.
     */

    mode = (PINB & _BV(B_MODE)) ? 0 : 1;
 6f8:	16 b3       	in	r17, 0x16	; 22
 6fa:	12 95       	swap	r17
 6fc:	16 95       	lsr	r17
 6fe:	17 70       	andi	r17, 0x07	; 7
 700:	10 95       	com	r17
 702:	11 70       	andi	r17, 0x01	; 1
    
    blink_led(mode+1, 150);
 704:	81 2f       	mov	r24, r17
 706:	90 e0       	ldi	r25, 0x00	; 0
 708:	01 96       	adiw	r24, 0x01	; 1
 70a:	66 e9       	ldi	r22, 0x96	; 150
 70c:	70 e0       	ldi	r23, 0x00	; 0
 70e:	d9 dc       	rcall	.-1614   	; 0xc2 <blink_led>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
 710:	82 eb       	ldi	r24, 0xB2	; 178
 712:	90 e0       	ldi	r25, 0x00	; 0
 714:	60 e0       	ldi	r22, 0x00	; 0
 716:	70 e0       	ldi	r23, 0x00	; 0
 718:	40 e0       	ldi	r20, 0x00	; 0
 71a:	52 e0       	ldi	r21, 0x02	; 2
 71c:	26 e4       	ldi	r18, 0x46	; 70
 71e:	30 e0       	ldi	r19, 0x00	; 0
 720:	3e d2       	rcall	.+1148   	; 0xb9e <__eerd_block>

/* Issue a reset pulse to the radio CPU */

void reset_radio(void)
{
    PORTB |= _BV(B_RRST);
 722:	c2 9a       	sbi	0x18, 2	; 24
 724:	84 ef       	ldi	r24, 0xF4	; 244
 726:	91 e0       	ldi	r25, 0x01	; 1
 728:	01 97       	sbiw	r24, 0x01	; 1
 72a:	f1 f7       	brne	.-4      	; 0x728 <main+0x58>
    /* ~100us */
    _delay_loop_2(5*100);
    PORTB &= ~(_BV(B_RRST));
 72c:	c2 98       	cbi	0x18, 2	; 24

/* Here we startup any interrupts or devices needed */

void start_ints(void)
{
    cli();
 72e:	f8 94       	cli
    /* enable the timer/counter1 overflow interrupt in the T/C int mask register */
    timer_enable_int(_BV(TOIE1));
#endif

	// Enable the external interrupt for INT0/PD2
    MCUCR   = (1<<ISC00);       // Set interrupt on fall and on rise
 730:	81 e0       	ldi	r24, 0x01	; 1
 732:	85 bf       	out	0x35, r24	; 53
    GICR	= (1<<INT0);		// Enable interrupt for interrupt0
 734:	80 e4       	ldi	r24, 0x40	; 64
 736:	8b bf       	out	0x3b, r24	; 59

    sei();
 738:	78 94       	sei

    /*
     * Enter the main X2212 EPROM emulation loop.
     */

    bankoff = (mode) ? BANKSIZE : 0;
 73a:	11 23       	and	r17, r17
 73c:	19 f4       	brne	.+6      	; 0x744 <main+0x74>
 73e:	80 e0       	ldi	r24, 0x00	; 0
 740:	90 e0       	ldi	r25, 0x00	; 0
 742:	02 c0       	rjmp	.+4      	; 0x748 <main+0x78>
 744:	80 e0       	ldi	r24, 0x00	; 0
 746:	91 e0       	ldi	r25, 0x01	; 1
 748:	ee 24       	eor	r14, r14
 74a:	ff 24       	eor	r15, r15
 74c:	87 01       	movw	r16, r14

            /* read the address data lines */
            addr = (PINC & 0x3F) + (PINB << 6);

            /* output the data to the buss */
            PORTD = s_bank[addr+bankoff] << 4;
 74e:	ec 01       	movw	r28, r24
 750:	ce 54       	subi	r28, 0x4E	; 78
 752:	df 4f       	sbci	r29, 0xFF	; 255
        {
            /* LED blink state counter */
            if (++count == 250000)
            {
                count = 0;
                PORTB ^= _BV(B_LED);
 754:	20 e1       	ldi	r18, 0x10	; 16
 756:	d2 2e       	mov	r13, r18
    for (;;)
    {
        /* TEST FOR /CS ACTIVE (low) */

        //if (s_cs1)
        if ((PIND & _BV(B_CS)) == 0)
 758:	82 99       	sbic	0x10, 2	; 16
 75a:	11 c0       	rjmp	.+34     	; 0x77e <main+0xae>
        {
            /* EPROM READ /CS ACTIVE STATE */

            PORTB |= _BV(B_LED);
 75c:	c4 9a       	sbi	0x18, 4	; 24

            /* read the address data lines */
            addr = (PINC & 0x3F) + (PINB << 6);
 75e:	93 b3       	in	r25, 0x13	; 19
 760:	86 b3       	in	r24, 0x16	; 22

            /* output the data to the buss */
            PORTD = s_bank[addr+bankoff] << 4;
 762:	82 95       	swap	r24
 764:	88 0f       	add	r24, r24
 766:	88 0f       	add	r24, r24
 768:	80 7c       	andi	r24, 0xC0	; 192
 76a:	9f 73       	andi	r25, 0x3F	; 63
 76c:	89 0f       	add	r24, r25
 76e:	fe 01       	movw	r30, r28
 770:	e8 0f       	add	r30, r24
 772:	f1 1d       	adc	r31, r1
 774:	80 81       	ld	r24, Z
 776:	82 95       	swap	r24
 778:	80 7f       	andi	r24, 0xF0	; 240
 77a:	82 bb       	out	0x12, r24	; 18
 77c:	ed cf       	rjmp	.-38     	; 0x758 <main+0x88>
            //PORTD = s_bank[addr] << 4;
        }
        else
        {
            /* LED blink state counter */
            if (++count == 250000)
 77e:	08 94       	sec
 780:	e1 1c       	adc	r14, r1
 782:	f1 1c       	adc	r15, r1
 784:	01 1d       	adc	r16, r1
 786:	11 1d       	adc	r17, r1
 788:	80 e9       	ldi	r24, 0x90	; 144
 78a:	e8 16       	cp	r14, r24
 78c:	80 ed       	ldi	r24, 0xD0	; 208
 78e:	f8 06       	cpc	r15, r24
 790:	83 e0       	ldi	r24, 0x03	; 3
 792:	08 07       	cpc	r16, r24
 794:	80 e0       	ldi	r24, 0x00	; 0
 796:	18 07       	cpc	r17, r24
 798:	31 f4       	brne	.+12     	; 0x7a6 <main+0xd6>
            {
                count = 0;
                PORTB ^= _BV(B_LED);
 79a:	88 b3       	in	r24, 0x18	; 24
 79c:	8d 25       	eor	r24, r13
 79e:	88 bb       	out	0x18, r24	; 24
 7a0:	ee 24       	eor	r14, r14
 7a2:	ff 24       	eor	r15, r15
 7a4:	87 01       	movw	r16, r14
            }

            /* RS-232 SERIAL PORT PROCESSING */

            /* Any character received? */
            if ((c = asi_getc()) != '.')
 7a6:	29 d0       	rcall	.+82     	; 0x7fa <asi_getc>
 7a8:	8e 97       	sbiw	r24, 0x2e	; 46
 7aa:	b1 f6       	brne	.-84     	; 0x758 <main+0x88>
                continue;

            /* LED off while we read from serial */
            PORTB &= ~(_BV(B_LED));
 7ac:	c4 98       	cbi	0x18, 4	; 24

            /* Got a period, echo back STX to begin packet rx */
            asi_putc(STX);
 7ae:	82 e0       	ldi	r24, 0x02	; 2
 7b0:	81 d0       	rcall	.+258    	; 0x8b4 <asi_putc>
            /* Attempt to read a data/command packet */

            do {

                /* attempt to read a packet */
                stat = rx_packet(); 
 7b2:	db dd       	rcall	.-1098   	; 0x36a <rx_packet>

            } while (stat == 0);
 7b4:	89 2b       	or	r24, r25
 7b6:	e9 f3       	breq	.-6      	; 0x7b2 <main+0xe2>
 7b8:	cf cf       	rjmp	.-98     	; 0x758 <main+0x88>

000007ba <asi_init>:

void asi_init(void) 
{
#if defined(__AVR_ATmega8__)
    /* Set baud rate */
    UBRRH = 0;
 7ba:	10 bc       	out	0x20, r1	; 32
    UBRRL = (uint8_t)((F_CPU / (16UL * BAUD_RATE)) - 1UL);
 7bc:	8f e5       	ldi	r24, 0x5F	; 95
 7be:	89 b9       	out	0x09, r24	; 9
    /* Enable receiver, transmitter and rx interrupts */
    UCSRB = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
 7c0:	88 e9       	ldi	r24, 0x98	; 152
 7c2:	8a b9       	out	0x0a, r24	; 10
    // Set frame format to 8 data bits, no parity, and 1stop bit
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
 7c4:	86 e8       	ldi	r24, 0x86	; 134
 7c6:	80 bd       	out	0x20, r24	; 32
    /* Enable the RTS and CTS outputs */
	//PORTE |= _BV(COM_RTS) | _BV(COM_CTS);
#endif

    /* Setup async ring buffer pointers */
    async.rx.head  = 0;     /* tx queue head index */
 7c8:	10 92 93 00 	sts	0x0093, r1
 7cc:	10 92 92 00 	sts	0x0092, r1
    async.rx.tail  = 0;     /* tx queue tail index */
 7d0:	10 92 95 00 	sts	0x0095, r1
 7d4:	10 92 94 00 	sts	0x0094, r1
    async.rx.count = 0;     /* tx queue size       */
 7d8:	10 92 97 00 	sts	0x0097, r1
 7dc:	10 92 96 00 	sts	0x0096, r1

    async.tx.head  = 0;     /* tx queue head index */
 7e0:	10 92 a9 00 	sts	0x00A9, r1
 7e4:	10 92 a8 00 	sts	0x00A8, r1
    async.tx.tail  = 0;     /* tx queue tail index */
 7e8:	10 92 ab 00 	sts	0x00AB, r1
 7ec:	10 92 aa 00 	sts	0x00AA, r1
    async.tx.count = 0;     /* tx queue size       */
 7f0:	10 92 ad 00 	sts	0x00AD, r1
 7f4:	10 92 ac 00 	sts	0x00AC, r1

    /* hook to stdlib printf() functions etc */
	//fdevopen(asi_putc, NULL, 0);
}
 7f8:	08 95       	ret

000007fa <asi_getc>:
int asi_getc(void)
{
    int     c = -1;
    size_t  head;

    if (async.rx.head != async.rx.tail)
 7fa:	20 91 92 00 	lds	r18, 0x0092
 7fe:	30 91 93 00 	lds	r19, 0x0093
 802:	80 91 94 00 	lds	r24, 0x0094
 806:	90 91 95 00 	lds	r25, 0x0095
 80a:	28 17       	cp	r18, r24
 80c:	39 07       	cpc	r19, r25
 80e:	19 f4       	brne	.+6      	; 0x816 <asi_getc+0x1c>
 810:	ef ef       	ldi	r30, 0xFF	; 255
 812:	ff ef       	ldi	r31, 0xFF	; 255
 814:	19 c0       	rjmp	.+50     	; 0x848 <asi_getc+0x4e>
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */
 816:	f9 01       	movw	r30, r18
 818:	ee 58       	subi	r30, 0x8E	; 142
 81a:	ff 4f       	sbci	r31, 0xFF	; 255
 81c:	e0 81       	ld	r30, Z
 81e:	2f 5f       	subi	r18, 0xFF	; 255
 820:	3f 4f       	sbci	r19, 0xFF	; 255

        c &= 0xff;

        --(async.rx.count);                         /* dec buffer count  */
 822:	80 91 96 00 	lds	r24, 0x0096
 826:	90 91 97 00 	lds	r25, 0x0097
 82a:	01 97       	sbiw	r24, 0x01	; 1
 82c:	90 93 97 00 	sts	0x0097, r25
 830:	80 93 96 00 	sts	0x0096, r24

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 834:	20 32       	cpi	r18, 0x20	; 32
 836:	31 05       	cpc	r19, r1
 838:	10 f0       	brcs	.+4      	; 0x83e <asi_getc+0x44>
 83a:	20 e0       	ldi	r18, 0x00	; 0
 83c:	30 e0       	ldi	r19, 0x00	; 0
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */

        c &= 0xff;
 83e:	f0 e0       	ldi	r31, 0x00	; 0

        --(async.rx.count);                         /* dec buffer count  */

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 840:	30 93 93 00 	sts	0x0093, r19
 844:	20 93 92 00 	sts	0x0092, r18
    }

    return c;
}
 848:	cf 01       	movw	r24, r30
 84a:	08 95       	ret

0000084c <asi_read>:
 *
 * Return:      Number of characters actually read.
 */

int asi_read(char *buf, size_t buflen)
{
 84c:	cf 93       	push	r28
 84e:	df 93       	push	r29
 850:	eb 01       	movw	r28, r22
 852:	dc 01       	movw	r26, r24
 854:	40 e0       	ldi	r20, 0x00	; 0
 856:	50 e0       	ldi	r21, 0x00	; 0
 858:	26 c0       	rjmp	.+76     	; 0x8a6 <asi_read+0x5a>
int asi_getc(void)
{
    int     c = -1;
    size_t  head;

    if (async.rx.head != async.rx.tail)
 85a:	20 91 92 00 	lds	r18, 0x0092
 85e:	30 91 93 00 	lds	r19, 0x0093
 862:	80 91 94 00 	lds	r24, 0x0094
 866:	90 91 95 00 	lds	r25, 0x0095
 86a:	28 17       	cp	r18, r24
 86c:	39 07       	cpc	r19, r25
 86e:	f1 f0       	breq	.+60     	; 0x8ac <asi_read+0x60>
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */
 870:	f9 01       	movw	r30, r18
 872:	ee 58       	subi	r30, 0x8E	; 142
 874:	ff 4f       	sbci	r31, 0xFF	; 255
 876:	60 81       	ld	r22, Z
 878:	f9 01       	movw	r30, r18
 87a:	31 96       	adiw	r30, 0x01	; 1

        c &= 0xff;

        --(async.rx.count);                         /* dec buffer count  */
 87c:	80 91 96 00 	lds	r24, 0x0096
 880:	90 91 97 00 	lds	r25, 0x0097
 884:	01 97       	sbiw	r24, 0x01	; 1
 886:	90 93 97 00 	sts	0x0097, r25
 88a:	80 93 96 00 	sts	0x0096, r24

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 88e:	e0 32       	cpi	r30, 0x20	; 32
 890:	f1 05       	cpc	r31, r1
 892:	10 f0       	brcs	.+4      	; 0x898 <asi_read+0x4c>
 894:	e0 e0       	ldi	r30, 0x00	; 0
 896:	f0 e0       	ldi	r31, 0x00	; 0
 898:	f0 93 93 00 	sts	0x0093, r31
 89c:	e0 93 92 00 	sts	0x0092, r30
    for (i=0; i < buflen; i++, p++)
    {
        if ((ch = asi_getc()) == -1)
            break;

        *p = (char)ch;
 8a0:	6d 93       	st	X+, r22
    char *p = buf;
    int  i;
    int  ch;
    int  cnt = 0;

    for (i=0; i < buflen; i++, p++)
 8a2:	4f 5f       	subi	r20, 0xFF	; 255
 8a4:	5f 4f       	sbci	r21, 0xFF	; 255
 8a6:	4c 17       	cp	r20, r28
 8a8:	5d 07       	cpc	r21, r29
 8aa:	b8 f2       	brcs	.-82     	; 0x85a <asi_read+0xe>
        ++cnt;
    }

    return cnt;

}
 8ac:	ca 01       	movw	r24, r20
 8ae:	df 91       	pop	r29
 8b0:	cf 91       	pop	r28
 8b2:	08 95       	ret

000008b4 <asi_putc>:

#if 1
int asi_putc(char c) 
{
    /* Wait for empty transmit buffer */
    loop_until_bit_is_set(UCSRA, UDRE); 
 8b4:	5d 9b       	sbis	0x0b, 5	; 11
 8b6:	fe cf       	rjmp	.-4      	; 0x8b4 <asi_putc>
    /* Sends a single char over the UART */
    UDR = (uint8_t)c;
 8b8:	8c b9       	out	0x0c, r24	; 12
    return 0;
}
 8ba:	80 e0       	ldi	r24, 0x00	; 0
 8bc:	90 e0       	ldi	r25, 0x00	; 0
 8be:	08 95       	ret

000008c0 <asi_write>:
#endif



int asi_write(char *buf, size_t buflen)
{
 8c0:	20 e0       	ldi	r18, 0x00	; 0
 8c2:	30 e0       	ldi	r19, 0x00	; 0
 8c4:	09 c0       	rjmp	.+18     	; 0x8d8 <asi_write+0x18>
    int  i;
    int  cnt = 0;

    for (i=0; i < buflen; i++)
    {
        if (asi_putc(*(buf+i)) == -1)
 8c6:	fc 01       	movw	r30, r24
 8c8:	e2 0f       	add	r30, r18
 8ca:	f3 1f       	adc	r31, r19
 8cc:	e0 81       	ld	r30, Z

#if 1
int asi_putc(char c) 
{
    /* Wait for empty transmit buffer */
    loop_until_bit_is_set(UCSRA, UDRE); 
 8ce:	5d 9b       	sbis	0x0b, 5	; 11
 8d0:	fe cf       	rjmp	.-4      	; 0x8ce <asi_write+0xe>
    /* Sends a single char over the UART */
    UDR = (uint8_t)c;
 8d2:	ec b9       	out	0x0c, r30	; 12
int asi_write(char *buf, size_t buflen)
{
    int  i;
    int  cnt = 0;

    for (i=0; i < buflen; i++)
 8d4:	2f 5f       	subi	r18, 0xFF	; 255
 8d6:	3f 4f       	sbci	r19, 0xFF	; 255
 8d8:	26 17       	cp	r18, r22
 8da:	37 07       	cpc	r19, r23
 8dc:	a0 f3       	brcs	.-24     	; 0x8c6 <asi_write+0x6>
            break;
    }

    return cnt;

}
 8de:	80 e0       	ldi	r24, 0x00	; 0
 8e0:	90 e0       	ldi	r25, 0x00	; 0
 8e2:	08 95       	ret

000008e4 <__vector_13>:
 * USART TX/RX INTERRUPT HANDLERS
 ***************************************************************************/

//SIGNAL(SIG_USART0_TRANS)
SIGNAL(SIG_UART_TRANS)
{
 8e4:	1f 92       	push	r1
 8e6:	0f 92       	push	r0
 8e8:	0f b6       	in	r0, 0x3f	; 63
 8ea:	0f 92       	push	r0
 8ec:	11 24       	eor	r1, r1
}
 8ee:	0f 90       	pop	r0
 8f0:	0f be       	out	0x3f, r0	; 63
 8f2:	0f 90       	pop	r0
 8f4:	1f 90       	pop	r1
 8f6:	18 95       	reti

000008f8 <__vector_12>:

/* TRANSMIT INTERRUPT HANDLER */

//SIGNAL(SIG_USART0_DATA)
SIGNAL(SIG_UART_DATA)
{
 8f8:	1f 92       	push	r1
 8fa:	0f 92       	push	r0
 8fc:	0f b6       	in	r0, 0x3f	; 63
 8fe:	0f 92       	push	r0
 900:	11 24       	eor	r1, r1
 902:	2f 93       	push	r18
 904:	3f 93       	push	r19
 906:	4f 93       	push	r20
 908:	8f 93       	push	r24
 90a:	9f 93       	push	r25
 90c:	ef 93       	push	r30
 90e:	ff 93       	push	r31
    char    c;
    size_t  n;

    if (async.tx.head == async.tx.tail)             /* get head pointer   */
 910:	20 91 a8 00 	lds	r18, 0x00A8
 914:	30 91 a9 00 	lds	r19, 0x00A9
 918:	80 91 aa 00 	lds	r24, 0x00AA
 91c:	90 91 ab 00 	lds	r25, 0x00AB
 920:	28 17       	cp	r18, r24
 922:	39 07       	cpc	r19, r25
 924:	31 f4       	brne	.+12     	; 0x932 <__vector_12+0x3a>
    {
#if defined(__AVR_ATmega8__)
		UCSRB &= ~(1<<UDRIE);
 926:	55 98       	cbi	0x0a, 5	; 10
#else
		UCSR0B &= ~(1<<UDRIE0);                     /* disable UDRE int's */
#endif
        async.tx.count = 0;                         /* reset buf count    */
 928:	10 92 ad 00 	sts	0x00AD, r1
 92c:	10 92 ac 00 	sts	0x00AC, r1
 930:	19 c0       	rjmp	.+50     	; 0x964 <__vector_12+0x6c>
    }
    else
    {
        n = async.tx.head;

        c = (uint8_t)async.tx.buf[n++];             /* get char in buff   */
 932:	f9 01       	movw	r30, r18
 934:	ee 58       	subi	r30, 0x8E	; 142
 936:	ff 4f       	sbci	r31, 0xFF	; 255
 938:	46 a1       	ldd	r20, Z+38	; 0x26
 93a:	f9 01       	movw	r30, r18
 93c:	31 96       	adiw	r30, 0x01	; 1

        --async.tx.count;                           /* dec buffer count   */
 93e:	80 91 ac 00 	lds	r24, 0x00AC
 942:	90 91 ad 00 	lds	r25, 0x00AD
 946:	01 97       	sbiw	r24, 0x01	; 1
 948:	90 93 ad 00 	sts	0x00AD, r25
 94c:	80 93 ac 00 	sts	0x00AC, r24

        async.tx.head = (n >= ASYNC_TX_BUFSIZE) ? 0 : n;
 950:	e0 31       	cpi	r30, 0x10	; 16
 952:	f1 05       	cpc	r31, r1
 954:	10 f0       	brcs	.+4      	; 0x95a <__vector_12+0x62>
 956:	e0 e0       	ldi	r30, 0x00	; 0
 958:	f0 e0       	ldi	r31, 0x00	; 0
 95a:	f0 93 a9 00 	sts	0x00A9, r31
 95e:	e0 93 a8 00 	sts	0x00A8, r30
        
#if defined(__AVR_ATmega8__)
        UDR = c;
 962:	4c b9       	out	0x0c, r20	; 12
#else
        UDR0 = c;                                   /* tx the character   */
#endif
    }
}
 964:	ff 91       	pop	r31
 966:	ef 91       	pop	r30
 968:	9f 91       	pop	r25
 96a:	8f 91       	pop	r24
 96c:	4f 91       	pop	r20
 96e:	3f 91       	pop	r19
 970:	2f 91       	pop	r18
 972:	0f 90       	pop	r0
 974:	0f be       	out	0x3f, r0	; 63
 976:	0f 90       	pop	r0
 978:	1f 90       	pop	r1
 97a:	18 95       	reti

0000097c <__vector_11>:

/* RECEIVE INTERRUPT HANDLER */

//SIGNAL(SIG_USART0_RECV)
SIGNAL(SIG_UART_RECV)
{
 97c:	1f 92       	push	r1
 97e:	0f 92       	push	r0
 980:	0f b6       	in	r0, 0x3f	; 63
 982:	0f 92       	push	r0
 984:	11 24       	eor	r1, r1
 986:	2f 93       	push	r18
 988:	3f 93       	push	r19
 98a:	8f 93       	push	r24
 98c:	9f 93       	push	r25
 98e:	ef 93       	push	r30
 990:	ff 93       	push	r31
    size_t  n;

    /* read line status and character data */

#if defined(__AVR_ATmega8__)
    stat = UCSRA;
 992:	9b b1       	in	r25, 0x0b	; 11
    data = UDR;
 994:	2c b1       	in	r18, 0x0c	; 12
#else
    stat = UCSR0A;                                  /* read status first! */
    data = UDR0;                                    /* read character     */
#endif

    if ((stat & (L_FRAMING_ERROR | L_PARITY_ERROR | L_DATA_OVERRUN)) != 0)
 996:	89 2f       	mov	r24, r25
 998:	8c 71       	andi	r24, 0x1C	; 28
 99a:	31 f0       	breq	.+12     	; 0x9a8 <__vector_11+0x2c>
    {
        async.stat.line |= stat;                    /* line status reg    */
 99c:	80 91 b0 00 	lds	r24, 0x00B0
 9a0:	89 2b       	or	r24, r25
 9a2:	80 93 b0 00 	sts	0x00B0, r24
 9a6:	2a c0       	rjmp	.+84     	; 0x9fc <__vector_11+0x80>
    }
    else
    {
        n = async.rx.tail;                          /* get tail index     */
 9a8:	80 91 94 00 	lds	r24, 0x0094
 9ac:	90 91 95 00 	lds	r25, 0x0095

        async.rx.buf[n++] = data;                   /* put char in buff   */
 9b0:	fc 01       	movw	r30, r24
 9b2:	ee 58       	subi	r30, 0x8E	; 142
 9b4:	ff 4f       	sbci	r31, 0xFF	; 255
 9b6:	20 83       	st	Z, r18
 9b8:	9c 01       	movw	r18, r24
 9ba:	2f 5f       	subi	r18, 0xFF	; 255
 9bc:	3f 4f       	sbci	r19, 0xFF	; 255

        if (n >= ASYNC_RX_BUFSIZE)                  /* tail wrap around?  */
 9be:	20 32       	cpi	r18, 0x20	; 32
 9c0:	31 05       	cpc	r19, r1
 9c2:	10 f0       	brcs	.+4      	; 0x9c8 <__vector_11+0x4c>
 9c4:	20 e0       	ldi	r18, 0x00	; 0
 9c6:	30 e0       	ldi	r19, 0x00	; 0
            n = 0;

        if (n == async.rx.head)                     /* buffer overflow?   */
 9c8:	80 91 92 00 	lds	r24, 0x0092
 9cc:	90 91 93 00 	lds	r25, 0x0093
 9d0:	28 17       	cp	r18, r24
 9d2:	39 07       	cpc	r19, r25
 9d4:	31 f4       	brne	.+12     	; 0x9e2 <__vector_11+0x66>
        {
            async.stat.flags |= A_RX_OVERFLOW;      /* yes, set flag      */
 9d6:	80 91 af 00 	lds	r24, 0x00AF
 9da:	82 60       	ori	r24, 0x02	; 2
 9dc:	80 93 af 00 	sts	0x00AF, r24
 9e0:	0d c0       	rjmp	.+26     	; 0x9fc <__vector_11+0x80>
        }
        else
        {
            async.rx.tail = n;                      /* new buffer tail    */
 9e2:	30 93 95 00 	sts	0x0095, r19
 9e6:	20 93 94 00 	sts	0x0094, r18

            ++(async.rx.count);                     /* inc buffer count   */
 9ea:	80 91 96 00 	lds	r24, 0x0096
 9ee:	90 91 97 00 	lds	r25, 0x0097
 9f2:	01 96       	adiw	r24, 0x01	; 1
 9f4:	90 93 97 00 	sts	0x0097, r25
 9f8:	80 93 96 00 	sts	0x0096, r24
        }
    }
}
 9fc:	ff 91       	pop	r31
 9fe:	ef 91       	pop	r30
 a00:	9f 91       	pop	r25
 a02:	8f 91       	pop	r24
 a04:	3f 91       	pop	r19
 a06:	2f 91       	pop	r18
 a08:	0f 90       	pop	r0
 a0a:	0f be       	out	0x3f, r0	; 63
 a0c:	0f 90       	pop	r0
 a0e:	1f 90       	pop	r1
 a10:	18 95       	reti

00000a12 <asi_puts>:
 *
 * Returns:     Number of characters sent to the modem.
 */

int asi_puts(char* p)
{
 a12:	cf 93       	push	r28
 a14:	df 93       	push	r29
 a16:	bc 01       	movw	r22, r24
int asi_getc(void)
{
    int     c = -1;
    size_t  head;

    if (async.rx.head != async.rx.tail)
 a18:	c0 91 94 00 	lds	r28, 0x0094
 a1c:	d0 91 95 00 	lds	r29, 0x0095
 a20:	40 e0       	ldi	r20, 0x00	; 0
 a22:	50 e0       	ldi	r21, 0x00	; 0
 a24:	2e c0       	rjmp	.+92     	; 0xa82 <asi_puts+0x70>
    size_t  i;

    for (i=0; i < strlen(p); i++)
    {
        /* handle ctrl characters   */
        if ((c = *(p+i)) == '^')
 a26:	fb 01       	movw	r30, r22
 a28:	e4 0f       	add	r30, r20
 a2a:	f5 1f       	adc	r31, r21
 a2c:	e0 81       	ld	r30, Z
 a2e:	ee 35       	cpi	r30, 0x5E	; 94
 a30:	39 f4       	brne	.+14     	; 0xa40 <asi_puts+0x2e>
        {
            ++i;
 a32:	4f 5f       	subi	r20, 0xFF	; 255
 a34:	5f 4f       	sbci	r21, 0xFF	; 255
            c = *(p+i) - '@';
 a36:	fb 01       	movw	r30, r22
 a38:	e4 0f       	add	r30, r20
 a3a:	f5 1f       	adc	r31, r21
 a3c:	e0 81       	ld	r30, Z
 a3e:	e0 54       	subi	r30, 0x40	; 64

#if 1
int asi_putc(char c) 
{
    /* Wait for empty transmit buffer */
    loop_until_bit_is_set(UCSRA, UDRE); 
 a40:	5d 9b       	sbis	0x0b, 5	; 11
 a42:	fe cf       	rjmp	.-4      	; 0xa40 <asi_puts+0x2e>
    /* Sends a single char over the UART */
    UDR = (uint8_t)c;
 a44:	ec b9       	out	0x0c, r30	; 12
int asi_getc(void)
{
    int     c = -1;
    size_t  head;

    if (async.rx.head != async.rx.tail)
 a46:	80 91 92 00 	lds	r24, 0x0092
 a4a:	90 91 93 00 	lds	r25, 0x0093
 a4e:	8c 17       	cp	r24, r28
 a50:	9d 07       	cpc	r25, r29
 a52:	a9 f0       	breq	.+42     	; 0xa7e <asi_puts+0x6c>
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */
 a54:	9c 01       	movw	r18, r24
 a56:	2f 5f       	subi	r18, 0xFF	; 255
 a58:	3f 4f       	sbci	r19, 0xFF	; 255

        c &= 0xff;

        --(async.rx.count);                         /* dec buffer count  */
 a5a:	80 91 96 00 	lds	r24, 0x0096
 a5e:	90 91 97 00 	lds	r25, 0x0097
 a62:	01 97       	sbiw	r24, 0x01	; 1
 a64:	90 93 97 00 	sts	0x0097, r25
 a68:	80 93 96 00 	sts	0x0096, r24

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 a6c:	20 32       	cpi	r18, 0x20	; 32
 a6e:	31 05       	cpc	r19, r1
 a70:	10 f0       	brcs	.+4      	; 0xa76 <asi_puts+0x64>
 a72:	20 e0       	ldi	r18, 0x00	; 0
 a74:	30 e0       	ldi	r19, 0x00	; 0
 a76:	30 93 93 00 	sts	0x0093, r19
 a7a:	20 93 92 00 	sts	0x0092, r18
int asi_puts(char* p)
{
    char    c;
    size_t  i;

    for (i=0; i < strlen(p); i++)
 a7e:	4f 5f       	subi	r20, 0xFF	; 255
 a80:	5f 4f       	sbci	r21, 0xFF	; 255
 a82:	fb 01       	movw	r30, r22
 a84:	01 90       	ld	r0, Z+
 a86:	00 20       	and	r0, r0
 a88:	e9 f7       	brne	.-6      	; 0xa84 <asi_puts+0x72>
 a8a:	31 97       	sbiw	r30, 0x01	; 1
 a8c:	e6 1b       	sub	r30, r22
 a8e:	f7 0b       	sbc	r31, r23
 a90:	4e 17       	cp	r20, r30
 a92:	5f 07       	cpc	r21, r31
 a94:	40 f2       	brcs	.-112    	; 0xa26 <asi_puts+0x14>
        /* get any echoed character */
        asi_getc();
    }

    return i;
}
 a96:	ca 01       	movw	r24, r20
 a98:	df 91       	pop	r29
 a9a:	cf 91       	pop	r28
 a9c:	08 95       	ret

00000a9e <asi_tgetc>:
 *
 * Return:      -1 if error occured.
 */

int asi_tgetc(int timeout)
{
 a9e:	0f 93       	push	r16
 aa0:	1f 93       	push	r17
 aa2:	cf 93       	push	r28
 aa4:	df 93       	push	r29
 aa6:	8c 01       	movw	r16, r24
    int c;
    int i;

    if (!timeout)                       /* timeout specified?   */
 aa8:	00 97       	sbiw	r24, 0x00	; 0
 aaa:	19 f0       	breq	.+6      	; 0xab2 <asi_tgetc+0x14>
 aac:	c0 e0       	ldi	r28, 0x00	; 0
 aae:	d0 e0       	ldi	r29, 0x00	; 0
 ab0:	35 c0       	rjmp	.+106    	; 0xb1c <asi_tgetc+0x7e>
int asi_getc(void)
{
    int     c = -1;
    size_t  head;

    if (async.rx.head != async.rx.tail)
 ab2:	20 91 92 00 	lds	r18, 0x0092
 ab6:	30 91 93 00 	lds	r19, 0x0093
 aba:	80 91 94 00 	lds	r24, 0x0094
 abe:	90 91 95 00 	lds	r25, 0x0095
 ac2:	28 17       	cp	r18, r24
 ac4:	39 07       	cpc	r19, r25
 ac6:	61 f4       	brne	.+24     	; 0xae0 <asi_tgetc+0x42>
 ac8:	2c c0       	rjmp	.+88     	; 0xb22 <asi_tgetc+0x84>
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */
 aca:	20 91 92 00 	lds	r18, 0x0092
 ace:	30 91 93 00 	lds	r19, 0x0093
 ad2:	80 91 94 00 	lds	r24, 0x0094
 ad6:	90 91 95 00 	lds	r25, 0x0095
 ada:	28 17       	cp	r18, r24
 adc:	39 07       	cpc	r19, r25
 ade:	d1 f0       	breq	.+52     	; 0xb14 <asi_tgetc+0x76>
 ae0:	f9 01       	movw	r30, r18
 ae2:	ee 58       	subi	r30, 0x8E	; 142
 ae4:	ff 4f       	sbci	r31, 0xFF	; 255
 ae6:	e0 81       	ld	r30, Z
 ae8:	2f 5f       	subi	r18, 0xFF	; 255
 aea:	3f 4f       	sbci	r19, 0xFF	; 255

        c &= 0xff;

        --(async.rx.count);                         /* dec buffer count  */
 aec:	80 91 96 00 	lds	r24, 0x0096
 af0:	90 91 97 00 	lds	r25, 0x0097
 af4:	01 97       	sbiw	r24, 0x01	; 1
 af6:	90 93 97 00 	sts	0x0097, r25
 afa:	80 93 96 00 	sts	0x0096, r24

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 afe:	20 32       	cpi	r18, 0x20	; 32
 b00:	31 05       	cpc	r19, r1
 b02:	10 f0       	brcs	.+4      	; 0xb08 <asi_tgetc+0x6a>
 b04:	20 e0       	ldi	r18, 0x00	; 0
 b06:	30 e0       	ldi	r19, 0x00	; 0
    {
        head = async.rx.head;                       /* get head pointer  */

        c = async.rx.buf[head++];                   /* get char in buff  */

        c &= 0xff;
 b08:	f0 e0       	ldi	r31, 0x00	; 0

        --(async.rx.count);                         /* dec buffer count  */

        async.rx.head = (head >= ASYNC_RX_BUFSIZE) ? 0 : head;
 b0a:	30 93 93 00 	sts	0x0093, r19
 b0e:	20 93 92 00 	sts	0x0092, r18
 b12:	09 c0       	rjmp	.+18     	; 0xb26 <asi_tgetc+0x88>
    for (i=0; i < timeout; i++)
    {
        if ((c = asi_getc()) != -1)     /* any character found? */
            return c;                   /* yes, return it       */

        SLEEP_MS(10);
 b14:	8a e0       	ldi	r24, 0x0A	; 10
 b16:	90 e0       	ldi	r25, 0x00	; 0
 b18:	09 db       	rcall	.-2542   	; 0x12c <delay_ms>
    int i;

    if (!timeout)                       /* timeout specified?   */
        return asi_getc();              /* no, just return it   */

    for (i=0; i < timeout; i++)
 b1a:	21 96       	adiw	r28, 0x01	; 1
 b1c:	c0 17       	cp	r28, r16
 b1e:	d1 07       	cpc	r29, r17
 b20:	a4 f2       	brlt	.-88     	; 0xaca <asi_tgetc+0x2c>
 b22:	ef ef       	ldi	r30, 0xFF	; 255
 b24:	ff ef       	ldi	r31, 0xFF	; 255

        SLEEP_MS(10);
    }

    return -1;
}
 b26:	cf 01       	movw	r24, r30
 b28:	df 91       	pop	r29
 b2a:	cf 91       	pop	r28
 b2c:	1f 91       	pop	r17
 b2e:	0f 91       	pop	r16
 b30:	08 95       	ret

00000b32 <asi_tgets>:
 *
 * Returns:     Number of characters sent to the modem.
 */

int asi_tgets(int timeout, char buf[])
{
 b32:	cf 92       	push	r12
 b34:	df 92       	push	r13
 b36:	ef 92       	push	r14
 b38:	ff 92       	push	r15
 b3a:	0f 93       	push	r16
 b3c:	1f 93       	push	r17
 b3e:	cf 93       	push	r28
 b40:	df 93       	push	r29
 b42:	6c 01       	movw	r12, r24
 b44:	7b 01       	movw	r14, r22
    int c;
    int i;

    buf[0] = '\0';
 b46:	fb 01       	movw	r30, r22
 b48:	10 82       	st	Z, r1
 b4a:	8b 01       	movw	r16, r22
 b4c:	c0 e0       	ldi	r28, 0x00	; 0
 b4e:	d0 e0       	ldi	r29, 0x00	; 0

    for (i=0; i < 63; i++)
    {
        if ((c = asi_tgetc(timeout)) == -1)
 b50:	c6 01       	movw	r24, r12
 b52:	a5 df       	rcall	.-182    	; 0xa9e <asi_tgetc>
 b54:	ff ef       	ldi	r31, 0xFF	; 255
 b56:	8f 3f       	cpi	r24, 0xFF	; 255
 b58:	9f 07       	cpc	r25, r31
 b5a:	19 f4       	brne	.+6      	; 0xb62 <asi_tgets+0x30>
 b5c:	c0 e0       	ldi	r28, 0x00	; 0
 b5e:	d0 e0       	ldi	r29, 0x00	; 0
 b60:	14 c0       	rjmp	.+40     	; 0xb8a <asi_tgets+0x58>
            return(0);

        if (c == '\r') 
 b62:	8d 30       	cpi	r24, 0x0D	; 13
 b64:	91 05       	cpc	r25, r1
 b66:	59 f0       	breq	.+22     	; 0xb7e <asi_tgets+0x4c>
            continue;

        if (c == '\n')
 b68:	8a 30       	cpi	r24, 0x0A	; 10
 b6a:	91 05       	cpc	r25, r1
 b6c:	29 f4       	brne	.+10     	; 0xb78 <asi_tgets+0x46>
        {
            buf[i] = '\0';
 b6e:	ec 0e       	add	r14, r28
 b70:	fd 1e       	adc	r15, r29
 b72:	f7 01       	movw	r30, r14
 b74:	10 82       	st	Z, r1
 b76:	09 c0       	rjmp	.+18     	; 0xb8a <asi_tgets+0x58>
            break;
        }

        buf[i] = (char)c;
 b78:	f8 01       	movw	r30, r16
 b7a:	80 83       	st	Z, r24
        buf[i+1] = '\0';
 b7c:	11 82       	std	Z+1, r1	; 0x01
    int c;
    int i;

    buf[0] = '\0';

    for (i=0; i < 63; i++)
 b7e:	21 96       	adiw	r28, 0x01	; 1
 b80:	0f 5f       	subi	r16, 0xFF	; 255
 b82:	1f 4f       	sbci	r17, 0xFF	; 255
 b84:	cf 33       	cpi	r28, 0x3F	; 63
 b86:	d1 05       	cpc	r29, r1
 b88:	19 f7       	brne	.-58     	; 0xb50 <asi_tgets+0x1e>
        buf[i] = (char)c;
        buf[i+1] = '\0';
    }

    return i;
}
 b8a:	ce 01       	movw	r24, r28
 b8c:	df 91       	pop	r29
 b8e:	cf 91       	pop	r28
 b90:	1f 91       	pop	r17
 b92:	0f 91       	pop	r16
 b94:	ff 90       	pop	r15
 b96:	ef 90       	pop	r14
 b98:	df 90       	pop	r13
 b9a:	cf 90       	pop	r12
 b9c:	08 95       	ret

00000b9e <__eerd_block>:
 b9e:	a0 e0       	ldi	r26, 0x00	; 0
 ba0:	b0 e0       	ldi	r27, 0x00	; 0
 ba2:	e4 ed       	ldi	r30, 0xD4	; 212
 ba4:	f5 e0       	ldi	r31, 0x05	; 5
 ba6:	4d c0       	rjmp	.+154    	; 0xc42 <__prologue_saves__+0x14>
 ba8:	7c 01       	movw	r14, r24
 baa:	eb 01       	movw	r28, r22
 bac:	8a 01       	movw	r16, r20
 bae:	69 01       	movw	r12, r18
 bb0:	09 c0       	rjmp	.+18     	; 0xbc4 <__eerd_block+0x26>
 bb2:	ce 01       	movw	r24, r28
 bb4:	21 96       	adiw	r28, 0x01	; 1
 bb6:	f6 01       	movw	r30, r12
 bb8:	09 95       	icall
 bba:	f7 01       	movw	r30, r14
 bbc:	81 93       	st	Z+, r24
 bbe:	7f 01       	movw	r14, r30
 bc0:	01 50       	subi	r16, 0x01	; 1
 bc2:	10 40       	sbci	r17, 0x00	; 0
 bc4:	01 15       	cp	r16, r1
 bc6:	11 05       	cpc	r17, r1
 bc8:	a1 f7       	brne	.-24     	; 0xbb2 <__eerd_block+0x14>
 bca:	cd b7       	in	r28, 0x3d	; 61
 bcc:	de b7       	in	r29, 0x3e	; 62
 bce:	e8 e0       	ldi	r30, 0x08	; 8
 bd0:	54 c0       	rjmp	.+168    	; 0xc7a <__epilogue_restores__+0x14>

00000bd2 <__eewr_block>:
 bd2:	a0 e0       	ldi	r26, 0x00	; 0
 bd4:	b0 e0       	ldi	r27, 0x00	; 0
 bd6:	ee ee       	ldi	r30, 0xEE	; 238
 bd8:	f5 e0       	ldi	r31, 0x05	; 5
 bda:	33 c0       	rjmp	.+102    	; 0xc42 <__prologue_saves__+0x14>
 bdc:	ec 01       	movw	r28, r24
 bde:	7b 01       	movw	r14, r22
 be0:	8a 01       	movw	r16, r20
 be2:	69 01       	movw	r12, r18
 be4:	09 c0       	rjmp	.+18     	; 0xbf8 <__eewr_block+0x26>
 be6:	ce 01       	movw	r24, r28
 be8:	21 96       	adiw	r28, 0x01	; 1
 bea:	f7 01       	movw	r30, r14
 bec:	61 91       	ld	r22, Z+
 bee:	7f 01       	movw	r14, r30
 bf0:	f6 01       	movw	r30, r12
 bf2:	09 95       	icall
 bf4:	01 50       	subi	r16, 0x01	; 1
 bf6:	10 40       	sbci	r17, 0x00	; 0
 bf8:	01 15       	cp	r16, r1
 bfa:	11 05       	cpc	r17, r1
 bfc:	a1 f7       	brne	.-24     	; 0xbe6 <__eewr_block+0x14>
 bfe:	cd b7       	in	r28, 0x3d	; 61
 c00:	de b7       	in	r29, 0x3e	; 62
 c02:	e8 e0       	ldi	r30, 0x08	; 8
 c04:	3a c0       	rjmp	.+116    	; 0xc7a <__epilogue_restores__+0x14>

00000c06 <__udivmodhi4>:
 c06:	aa 1b       	sub	r26, r26
 c08:	bb 1b       	sub	r27, r27
 c0a:	51 e1       	ldi	r21, 0x11	; 17
 c0c:	07 c0       	rjmp	.+14     	; 0xc1c <__udivmodhi4_ep>

00000c0e <__udivmodhi4_loop>:
 c0e:	aa 1f       	adc	r26, r26
 c10:	bb 1f       	adc	r27, r27
 c12:	a6 17       	cp	r26, r22
 c14:	b7 07       	cpc	r27, r23
 c16:	10 f0       	brcs	.+4      	; 0xc1c <__udivmodhi4_ep>
 c18:	a6 1b       	sub	r26, r22
 c1a:	b7 0b       	sbc	r27, r23

00000c1c <__udivmodhi4_ep>:
 c1c:	88 1f       	adc	r24, r24
 c1e:	99 1f       	adc	r25, r25
 c20:	5a 95       	dec	r21
 c22:	a9 f7       	brne	.-22     	; 0xc0e <__udivmodhi4_loop>
 c24:	80 95       	com	r24
 c26:	90 95       	com	r25
 c28:	bc 01       	movw	r22, r24
 c2a:	cd 01       	movw	r24, r26
 c2c:	08 95       	ret

00000c2e <__prologue_saves__>:
 c2e:	2f 92       	push	r2
 c30:	3f 92       	push	r3
 c32:	4f 92       	push	r4
 c34:	5f 92       	push	r5
 c36:	6f 92       	push	r6
 c38:	7f 92       	push	r7
 c3a:	8f 92       	push	r8
 c3c:	9f 92       	push	r9
 c3e:	af 92       	push	r10
 c40:	bf 92       	push	r11
 c42:	cf 92       	push	r12
 c44:	df 92       	push	r13
 c46:	ef 92       	push	r14
 c48:	ff 92       	push	r15
 c4a:	0f 93       	push	r16
 c4c:	1f 93       	push	r17
 c4e:	cf 93       	push	r28
 c50:	df 93       	push	r29
 c52:	cd b7       	in	r28, 0x3d	; 61
 c54:	de b7       	in	r29, 0x3e	; 62
 c56:	ca 1b       	sub	r28, r26
 c58:	db 0b       	sbc	r29, r27
 c5a:	0f b6       	in	r0, 0x3f	; 63
 c5c:	f8 94       	cli
 c5e:	de bf       	out	0x3e, r29	; 62
 c60:	0f be       	out	0x3f, r0	; 63
 c62:	cd bf       	out	0x3d, r28	; 61
 c64:	09 94       	ijmp

00000c66 <__epilogue_restores__>:
 c66:	2a 88       	ldd	r2, Y+18	; 0x12
 c68:	39 88       	ldd	r3, Y+17	; 0x11
 c6a:	48 88       	ldd	r4, Y+16	; 0x10
 c6c:	5f 84       	ldd	r5, Y+15	; 0x0f
 c6e:	6e 84       	ldd	r6, Y+14	; 0x0e
 c70:	7d 84       	ldd	r7, Y+13	; 0x0d
 c72:	8c 84       	ldd	r8, Y+12	; 0x0c
 c74:	9b 84       	ldd	r9, Y+11	; 0x0b
 c76:	aa 84       	ldd	r10, Y+10	; 0x0a
 c78:	b9 84       	ldd	r11, Y+9	; 0x09
 c7a:	c8 84       	ldd	r12, Y+8	; 0x08
 c7c:	df 80       	ldd	r13, Y+7	; 0x07
 c7e:	ee 80       	ldd	r14, Y+6	; 0x06
 c80:	fd 80       	ldd	r15, Y+5	; 0x05
 c82:	0c 81       	ldd	r16, Y+4	; 0x04
 c84:	1b 81       	ldd	r17, Y+3	; 0x03
 c86:	aa 81       	ldd	r26, Y+2	; 0x02
 c88:	b9 81       	ldd	r27, Y+1	; 0x01
 c8a:	ce 0f       	add	r28, r30
 c8c:	d1 1d       	adc	r29, r1
 c8e:	0f b6       	in	r0, 0x3f	; 63
 c90:	f8 94       	cli
 c92:	de bf       	out	0x3e, r29	; 62
 c94:	0f be       	out	0x3f, r0	; 63
 c96:	cd bf       	out	0x3d, r28	; 61
 c98:	ed 01       	movw	r28, r26
 c9a:	08 95       	ret

00000c9c <_exit>:
 c9c:	f8 94       	cli

00000c9e <__stop_program>:
 c9e:	ff cf       	rjmp	.-2      	; 0xc9e <__stop_program>
